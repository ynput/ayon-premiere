{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"index.html","title":"Premiere Addon","text":"<p>Integration with Adobe Premiere.</p> <p>Supports workfile management, eg. opening existing, publishing new ones.</p> <p>Supports usage of file Loader, which allows loading AYON controlled assets like movies, image sequences, audio files, etc. Supports management of loaded items, eg. updates.</p>"},{"location":"index.html#installation","title":"Installation","text":"<p>Manually install <code>ayon-premiere/client/ayon_premiere/api/extension.zxp</code> via Anastasiy (https://install.anastasiy.com/index.html) or ExmanCmd (installs into <code>Program Files</code> - requires admin permissions) OR enable <code>client/ayon_premiere/hooks/pre_launch_install_ayon_extension.py</code> hook (installs into <code>AppData</code>)</p>"},{"location":"index.html#developing","title":"Developing","text":""},{"location":"index.html#extension","title":"Extension","text":"<p>When developing the extension you can load it unsigned.</p> <p>When signing the extension you can use this guide.</p> <pre><code>ZXPSignCmd -selfSignedCert NA NA Ayon ayon-premiere Ayon extension.p12\nZXPSignCmd -sign {path to ayon-premiere}\\client\\ayon-premiere\\api\\extension {path to ayon-premiere}\\client\\ayon-premiere\\api\\extension.zxp extension.p12 ayon\n</code></pre> <p>Any change to extension should also contain bump of <code>ExtensionBundleVersion</code> in <code>ayon_premiere/api/extension/CSXS/manifest.xml</code>.</p> <p>For easier debugging of Javascript: https://community.adobe.com/t5/download-install/adobe-extension-debuger-problem/td-p/10911704?page=1 Add --enable-blink-features=ShadowDOMV0,CustomElementsV0 when starting Chrome then localhost:8078 (port set in <code>ayon-premiere}\\client\\ayon-premiere\\api\\.debug</code>)</p> <p>Or use Visual Studio Code https://medium.com/adobetech/extendscript-debugger-for-visual-studio-code-public-release-a2ff6161fa01</p> <p>Or install CEF client from https://github.com/Adobe-CEP/CEP-Resources/tree/master/CEP_9.x</p>"},{"location":"index.html#resources","title":"Resources","text":"<ul> <li>https://ppro-scripting.docsforadobe.dev/</li> <li>https://github.com/Adobe-CEP/Getting-Started-guides</li> <li>https://github.com/Adobe-CEP/CEP-Resources</li> </ul>"},{"location":"license.html","title":"License","text":"<pre><code>                             Apache License\n                       Version 2.0, January 2004\n                    http://www.apache.org/licenses/\n</code></pre> <p>TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION</p> <ol> <li> <p>Definitions.</p> <p>\"License\" shall mean the terms and conditions for use, reproduction,   and distribution as defined by Sections 1 through 9 of this document.</p> <p>\"Licensor\" shall mean the copyright owner or entity authorized by   the copyright owner that is granting the License.</p> <p>\"Legal Entity\" shall mean the union of the acting entity and all   other entities that control, are controlled by, or are under common   control with that entity. For the purposes of this definition,   \"control\" means (i) the power, direct or indirect, to cause the   direction or management of such entity, whether by contract or   otherwise, or (ii) ownership of fifty percent (50%) or more of the   outstanding shares, or (iii) beneficial ownership of such entity.</p> <p>\"You\" (or \"Your\") shall mean an individual or Legal Entity   exercising permissions granted by this License.</p> <p>\"Source\" form shall mean the preferred form for making modifications,   including but not limited to software source code, documentation   source, and configuration files.</p> <p>\"Object\" form shall mean any form resulting from mechanical   transformation or translation of a Source form, including but   not limited to compiled object code, generated documentation,   and conversions to other media types.</p> <p>\"Work\" shall mean the work of authorship, whether in Source or   Object form, made available under the License, as indicated by a   copyright notice that is included in or attached to the work   (an example is provided in the Appendix below).</p> <p>\"Derivative Works\" shall mean any work, whether in Source or Object   form, that is based on (or derived from) the Work and for which the   editorial revisions, annotations, elaborations, or other modifications   represent, as a whole, an original work of authorship. For the purposes   of this License, Derivative Works shall not include works that remain   separable from, or merely link (or bind by name) to the interfaces of,   the Work and Derivative Works thereof.</p> <p>\"Contribution\" shall mean any work of authorship, including   the original version of the Work and any modifications or additions   to that Work or Derivative Works thereof, that is intentionally   submitted to Licensor for inclusion in the Work by the copyright owner   or by an individual or Legal Entity authorized to submit on behalf of   the copyright owner. For the purposes of this definition, \"submitted\"   means any form of electronic, verbal, or written communication sent   to the Licensor or its representatives, including but not limited to   communication on electronic mailing lists, source code control systems,   and issue tracking systems that are managed by, or on behalf of, the   Licensor for the purpose of discussing and improving the Work, but   excluding communication that is conspicuously marked or otherwise   designated in writing by the copyright owner as \"Not a Contribution.\"</p> <p>\"Contributor\" shall mean Licensor and any individual or Legal Entity   on behalf of whom a Contribution has been received by Licensor and   subsequently incorporated within the Work.</p> </li> <li> <p>Grant of Copyright License. Subject to the terms and conditions of       this License, each Contributor hereby grants to You a perpetual,       worldwide, non-exclusive, no-charge, royalty-free, irrevocable       copyright license to reproduce, prepare Derivative Works of,       publicly display, publicly perform, sublicense, and distribute the       Work and such Derivative Works in Source or Object form.</p> </li> <li> <p>Grant of Patent License. Subject to the terms and conditions of       this License, each Contributor hereby grants to You a perpetual,       worldwide, non-exclusive, no-charge, royalty-free, irrevocable       (except as stated in this section) patent license to make, have made,       use, offer to sell, sell, import, and otherwise transfer the Work,       where such license applies only to those patent claims licensable       by such Contributor that are necessarily infringed by their       Contribution(s) alone or by combination of their Contribution(s)       with the Work to which such Contribution(s) was submitted. If You       institute patent litigation against any entity (including a       cross-claim or counterclaim in a lawsuit) alleging that the Work       or a Contribution incorporated within the Work constitutes direct       or contributory patent infringement, then any patent licenses       granted to You under this License for that Work shall terminate       as of the date such litigation is filed.</p> </li> <li> <p>Redistribution. You may reproduce and distribute copies of the       Work or Derivative Works thereof in any medium, with or without       modifications, and in Source or Object form, provided that You       meet the following conditions:</p> <p>(a) You must give any other recipients of the Work or       Derivative Works a copy of this License; and</p> <p>(b) You must cause any modified files to carry prominent notices       stating that You changed the files; and</p> <p>(c) You must retain, in the Source form of any Derivative Works       that You distribute, all copyright, patent, trademark, and       attribution notices from the Source form of the Work,       excluding those notices that do not pertain to any part of       the Derivative Works; and</p> <p>(d) If the Work includes a \"NOTICE\" text file as part of its       distribution, then any Derivative Works that You distribute must       include a readable copy of the attribution notices contained       within such NOTICE file, excluding those notices that do not       pertain to any part of the Derivative Works, in at least one       of the following places: within a NOTICE text file distributed       as part of the Derivative Works; within the Source form or       documentation, if provided along with the Derivative Works; or,       within a display generated by the Derivative Works, if and       wherever such third-party notices normally appear. The contents       of the NOTICE file are for informational purposes only and       do not modify the License. You may add Your own attribution       notices within Derivative Works that You distribute, alongside       or as an addendum to the NOTICE text from the Work, provided       that such additional attribution notices cannot be construed       as modifying the License.</p> <p>You may add Your own copyright statement to Your modifications and   may provide additional or different license terms and conditions   for use, reproduction, or distribution of Your modifications, or   for any such Derivative Works as a whole, provided Your use,   reproduction, and distribution of the Work otherwise complies with   the conditions stated in this License.</p> </li> <li> <p>Submission of Contributions. Unless You explicitly state otherwise,       any Contribution intentionally submitted for inclusion in the Work       by You to the Licensor shall be under the terms and conditions of       this License, without any additional terms or conditions.       Notwithstanding the above, nothing herein shall supersede or modify       the terms of any separate license agreement you may have executed       with Licensor regarding such Contributions.</p> </li> <li> <p>Trademarks. This License does not grant permission to use the trade       names, trademarks, service marks, or product names of the Licensor,       except as required for reasonable and customary use in describing the       origin of the Work and reproducing the content of the NOTICE file.</p> </li> <li> <p>Disclaimer of Warranty. Unless required by applicable law or       agreed to in writing, Licensor provides the Work (and each       Contributor provides its Contributions) on an \"AS IS\" BASIS,       WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or       implied, including, without limitation, any warranties or conditions       of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A       PARTICULAR PURPOSE. You are solely responsible for determining the       appropriateness of using or redistributing the Work and assume any       risks associated with Your exercise of permissions under this License.</p> </li> <li> <p>Limitation of Liability. In no event and under no legal theory,       whether in tort (including negligence), contract, or otherwise,       unless required by applicable law (such as deliberate and grossly       negligent acts) or agreed to in writing, shall any Contributor be       liable to You for damages, including any direct, indirect, special,       incidental, or consequential damages of any character arising as a       result of this License or out of the use or inability to use the       Work (including but not limited to damages for loss of goodwill,       work stoppage, computer failure or malfunction, or any and all       other commercial damages or losses), even if such Contributor       has been advised of the possibility of such damages.</p> </li> <li> <p>Accepting Warranty or Additional Liability. While redistributing       the Work or Derivative Works thereof, You may choose to offer,       and charge a fee for, acceptance of support, warranty, indemnity,       or other liability obligations and/or rights consistent with this       License. However, in accepting such obligations, You may act only       on Your own behalf and on Your sole responsibility, not on behalf       of any other Contributor, and only if You agree to indemnify,       defend, and hold each Contributor harmless for any liability       incurred by, or claims asserted against, such Contributor by reason       of your accepting any such warranty or additional liability.</p> </li> </ol> <p>END OF TERMS AND CONDITIONS</p> <p>APPENDIX: How to apply the Apache License to your work.</p> <pre><code>  To apply the Apache License to your work, attach the following\n  boilerplate notice, with the fields enclosed by brackets \"[]\"\n  replaced with your own identifying information. (Don't include\n  the brackets!)  The text should be enclosed in the appropriate\n  comment syntax for the file format. We also recommend that a\n  file or class name and description of purpose be included on the\n  same \"printed page\" as the copyright notice for easier\n  identification within third-party archives.\n</code></pre> <p>Copyright [yyyy][name of copyright owner]</p> <p>Licensed under the Apache License, Version 2.0 (the \"License\");    you may not use this file except in compliance with the License.    You may obtain a copy of the License at</p> <pre><code>   http://www.apache.org/licenses/LICENSE-2.0\n</code></pre> <p>Unless required by applicable law or agreed to in writing, software    distributed under the License is distributed on an \"AS IS\" BASIS,    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.    See the License for the specific language governing permissions and    limitations under the License.</p>"},{"location":"autoapi/summary.html","title":"Summary","text":"<ul> <li>client<ul> <li>ayon_premiere<ul> <li>addon</li> <li>api<ul> <li>launch_logic</li> <li>launch_script</li> <li>lib</li> <li>pipeline</li> <li>plugin</li> <li>webserver</li> <li>ws_stub</li> </ul> </li> <li>hooks<ul> <li>pre_launch_args</li> <li>pre_launch_install_ayon_extension</li> </ul> </li> <li>plugins<ul> <li>create<ul> <li>workfile_creator</li> </ul> </li> <li>load<ul> <li>load_aftereffects_comp</li> <li>load_file</li> </ul> </li> <li>publish<ul> <li>collect_current_file</li> <li>collect_workfile</li> <li>increment_workfile</li> </ul> </li> </ul> </li> <li>version</li> </ul> </li> </ul> </li> <li>server<ul> <li>settings</li> </ul> </li> </ul>"},{"location":"autoapi/client/ayon_premiere/index.html","title":"ayon_premiere","text":""},{"location":"autoapi/client/ayon_premiere/index.html#client.ayon_premiere.PremiereAddon","title":"<code>PremiereAddon</code>","text":"<p>               Bases: <code>AYONAddon</code>, <code>IHostAddon</code></p> Source code in <code>client/ayon_premiere/addon.py</code> <pre><code>class PremiereAddon(AYONAddon, IHostAddon):\n    name = \"premiere\"\n    version = __version__\n    host_name = \"premiere\"\n\n    def add_implementation_envs(self, env, _app):\n        \"\"\"Modify environments to contain all required for implementation.\"\"\"\n        defaults = {\n            \"AYON_LOG_NO_COLORS\": \"1\",\n            \"WEBSOCKET_URL\": \"ws://localhost:8096/ws/\"\n        }\n        for key, value in defaults.items():\n            if not env.get(key):\n                env[key] = value\n\n    def get_workfile_extensions(self):\n        return [\".prproj\"]\n\n    def get_launch_hook_paths(self, app):\n        if app.host_name != self.host_name:\n            return []\n        return [\n            os.path.join(PREMIERE_ADDON_ROOT, \"hooks\")\n        ]\n\n    def publish_in_test(self, log, close_plugin_name=None):\n        \"\"\"Runs publish in an opened host with a context.\n\n        Close Python process at the end.\n        \"\"\"\n\n        from ayon_premiere.api.lib import publish_in_test\n\n        publish_in_test(log, close_plugin_name)\n</code></pre>"},{"location":"autoapi/client/ayon_premiere/index.html#client.ayon_premiere.PremiereAddon.add_implementation_envs","title":"<code>add_implementation_envs(env, _app)</code>","text":"<p>Modify environments to contain all required for implementation.</p> Source code in <code>client/ayon_premiere/addon.py</code> <pre><code>def add_implementation_envs(self, env, _app):\n    \"\"\"Modify environments to contain all required for implementation.\"\"\"\n    defaults = {\n        \"AYON_LOG_NO_COLORS\": \"1\",\n        \"WEBSOCKET_URL\": \"ws://localhost:8096/ws/\"\n    }\n    for key, value in defaults.items():\n        if not env.get(key):\n            env[key] = value\n</code></pre>"},{"location":"autoapi/client/ayon_premiere/index.html#client.ayon_premiere.PremiereAddon.publish_in_test","title":"<code>publish_in_test(log, close_plugin_name=None)</code>","text":"<p>Runs publish in an opened host with a context.</p> <p>Close Python process at the end.</p> Source code in <code>client/ayon_premiere/addon.py</code> <pre><code>def publish_in_test(self, log, close_plugin_name=None):\n    \"\"\"Runs publish in an opened host with a context.\n\n    Close Python process at the end.\n    \"\"\"\n\n    from ayon_premiere.api.lib import publish_in_test\n\n    publish_in_test(log, close_plugin_name)\n</code></pre>"},{"location":"autoapi/client/ayon_premiere/addon.html","title":"addon","text":""},{"location":"autoapi/client/ayon_premiere/addon.html#client.ayon_premiere.addon.PremiereAddon","title":"<code>PremiereAddon</code>","text":"<p>               Bases: <code>AYONAddon</code>, <code>IHostAddon</code></p> Source code in <code>client/ayon_premiere/addon.py</code> <pre><code>class PremiereAddon(AYONAddon, IHostAddon):\n    name = \"premiere\"\n    version = __version__\n    host_name = \"premiere\"\n\n    def add_implementation_envs(self, env, _app):\n        \"\"\"Modify environments to contain all required for implementation.\"\"\"\n        defaults = {\n            \"AYON_LOG_NO_COLORS\": \"1\",\n            \"WEBSOCKET_URL\": \"ws://localhost:8096/ws/\"\n        }\n        for key, value in defaults.items():\n            if not env.get(key):\n                env[key] = value\n\n    def get_workfile_extensions(self):\n        return [\".prproj\"]\n\n    def get_launch_hook_paths(self, app):\n        if app.host_name != self.host_name:\n            return []\n        return [\n            os.path.join(PREMIERE_ADDON_ROOT, \"hooks\")\n        ]\n\n    def publish_in_test(self, log, close_plugin_name=None):\n        \"\"\"Runs publish in an opened host with a context.\n\n        Close Python process at the end.\n        \"\"\"\n\n        from ayon_premiere.api.lib import publish_in_test\n\n        publish_in_test(log, close_plugin_name)\n</code></pre>"},{"location":"autoapi/client/ayon_premiere/addon.html#client.ayon_premiere.addon.PremiereAddon.add_implementation_envs","title":"<code>add_implementation_envs(env, _app)</code>","text":"<p>Modify environments to contain all required for implementation.</p> Source code in <code>client/ayon_premiere/addon.py</code> <pre><code>def add_implementation_envs(self, env, _app):\n    \"\"\"Modify environments to contain all required for implementation.\"\"\"\n    defaults = {\n        \"AYON_LOG_NO_COLORS\": \"1\",\n        \"WEBSOCKET_URL\": \"ws://localhost:8096/ws/\"\n    }\n    for key, value in defaults.items():\n        if not env.get(key):\n            env[key] = value\n</code></pre>"},{"location":"autoapi/client/ayon_premiere/addon.html#client.ayon_premiere.addon.PremiereAddon.publish_in_test","title":"<code>publish_in_test(log, close_plugin_name=None)</code>","text":"<p>Runs publish in an opened host with a context.</p> <p>Close Python process at the end.</p> Source code in <code>client/ayon_premiere/addon.py</code> <pre><code>def publish_in_test(self, log, close_plugin_name=None):\n    \"\"\"Runs publish in an opened host with a context.\n\n    Close Python process at the end.\n    \"\"\"\n\n    from ayon_premiere.api.lib import publish_in_test\n\n    publish_in_test(log, close_plugin_name)\n</code></pre>"},{"location":"autoapi/client/ayon_premiere/version.html","title":"version","text":"<p>Package declaring AYON addon 'premiere' version.</p>"},{"location":"autoapi/client/ayon_premiere/api/index.html","title":"api","text":"<p>Public API</p> <p>Anything that isn't defined here is INTERNAL and unreliable for external use.</p>"},{"location":"autoapi/client/ayon_premiere/api/index.html#client.ayon_premiere.api.PremiereHost","title":"<code>PremiereHost</code>","text":"<p>               Bases: <code>HostBase</code>, <code>IWorkfileHost</code>, <code>ILoadHost</code>, <code>IPublishHost</code></p> Source code in <code>client/ayon_premiere/api/pipeline.py</code> <pre><code>class PremiereHost(HostBase, IWorkfileHost, ILoadHost, IPublishHost):\n    name = \"premiere\"\n\n    def __init__(self):\n        self._stub = None\n        super().__init__()\n\n    @property\n    def stub(self):\n        \"\"\"\n            Handle pulling stub from PS to run operations on host\n        Returns:\n            (AEServerStub) or None\n        \"\"\"\n        if self._stub:\n            return self._stub\n\n        try:\n            stub = get_stub()  # only after Photoshop is up\n        except ConnectionNotEstablishedYet:\n            print(\"Not connected yet, ignoring\")\n            return\n\n        self._stub = stub\n        return self._stub\n\n    def install(self):\n        print(\"Installing AYON config...\")\n\n        pyblish.api.register_host(self.name)\n        pyblish.api.register_plugin_path(PUBLISH_PATH)\n\n        register_loader_plugin_path(LOAD_PATH)\n        register_creator_plugin_path(CREATE_PATH)\n        register_workfile_build_plugin_path(WORKFILE_BUILD_PATH)\n\n        register_event_callback(\"application.launched\", application_launch)\n\n    def get_workfile_extensions(self):\n        return [\".prproj\"]\n\n    def save_workfile(self, dst_path=None):\n        self.stub.saveAs(dst_path, True)\n\n    def open_workfile(self, filepath):\n        self.stub.open(filepath)\n\n        return True\n\n    def get_current_workfile(self):\n        try:\n            full_name = get_stub().get_active_document_full_name()\n            if full_name and full_name != \"null\":\n                return os.path.normpath(full_name).replace(\"\\\\\", \"/\")\n        except ValueError:\n            print(\"Nothing opened\")\n            pass\n\n        return None\n\n    def get_containers(self):\n        return ls()\n\n    def get_context_data(self):\n        meta = self.stub.get_metadata()\n        for item in meta:\n            if item.get(\"id\") == \"publish_context\":\n                item.pop(\"id\")\n                return item\n\n        return {}\n\n    def update_context_data(self, data, changes):\n        item = data\n        item[\"id\"] = \"publish_context\"\n        self.stub.imprint(item[\"id\"], item)\n\n    # created instances section\n    def list_instances(self):\n        \"\"\"List all created instances from current workfile which\n        will be published.\n\n        Pulls from File &gt; File Info\n\n        For SubsetManager\n\n        Returns:\n            (list) of dictionaries matching instances format\n        \"\"\"\n        stub = self.stub\n        if not stub:\n            return []\n\n        instances = []\n        layers_meta = stub.get_metadata()\n\n        for instance in layers_meta:\n            if instance.get(\"id\") in {\n                AYON_INSTANCE_ID, AVALON_INSTANCE_ID\n            }:\n                instances.append(instance)\n        return instances\n\n    def remove_instance(self, instance):\n        \"\"\"Remove instance from current workfile metadata.\n\n        Updates metadata of current file in File &gt; File Info and removes\n        icon highlight on group layer.\n\n        For SubsetManager\n\n        Args:\n            instance (dict): instance representation from subsetmanager model\n        \"\"\"\n        stub = self.stub\n\n        if not stub:\n            return\n\n        inst_id = instance.get(\"instance_id\") or instance.get(\"uuid\")  # legacy\n        if not inst_id:\n            log.warning(\"No instance identifier for {}\".format(instance))\n            return\n\n        stub.remove_instance(inst_id)\n\n        if instance.get(\"members\"):\n            item = stub.get_item(instance[\"members\"][0])\n            if item:\n                stub.rename_item(item.id,\n                                 item.name.replace(stub.PUBLISH_ICON, ''))\n</code></pre>"},{"location":"autoapi/client/ayon_premiere/api/index.html#client.ayon_premiere.api.PremiereHost.stub","title":"<code>stub</code>  <code>property</code>","text":"<pre><code>Handle pulling stub from PS to run operations on host\n</code></pre> <p>Returns:     (AEServerStub) or None</p>"},{"location":"autoapi/client/ayon_premiere/api/index.html#client.ayon_premiere.api.PremiereHost.list_instances","title":"<code>list_instances()</code>","text":"<p>List all created instances from current workfile which will be published.</p> <p>Pulls from File &gt; File Info</p> <p>For SubsetManager</p> <p>Returns:</p> Type Description <p>(list) of dictionaries matching instances format</p> Source code in <code>client/ayon_premiere/api/pipeline.py</code> <pre><code>def list_instances(self):\n    \"\"\"List all created instances from current workfile which\n    will be published.\n\n    Pulls from File &gt; File Info\n\n    For SubsetManager\n\n    Returns:\n        (list) of dictionaries matching instances format\n    \"\"\"\n    stub = self.stub\n    if not stub:\n        return []\n\n    instances = []\n    layers_meta = stub.get_metadata()\n\n    for instance in layers_meta:\n        if instance.get(\"id\") in {\n            AYON_INSTANCE_ID, AVALON_INSTANCE_ID\n        }:\n            instances.append(instance)\n    return instances\n</code></pre>"},{"location":"autoapi/client/ayon_premiere/api/index.html#client.ayon_premiere.api.PremiereHost.remove_instance","title":"<code>remove_instance(instance)</code>","text":"<p>Remove instance from current workfile metadata.</p> <p>Updates metadata of current file in File &gt; File Info and removes icon highlight on group layer.</p> <p>For SubsetManager</p> <p>Parameters:</p> Name Type Description Default <code>instance</code> <code>dict</code> <p>instance representation from subsetmanager model</p> required Source code in <code>client/ayon_premiere/api/pipeline.py</code> <pre><code>def remove_instance(self, instance):\n    \"\"\"Remove instance from current workfile metadata.\n\n    Updates metadata of current file in File &gt; File Info and removes\n    icon highlight on group layer.\n\n    For SubsetManager\n\n    Args:\n        instance (dict): instance representation from subsetmanager model\n    \"\"\"\n    stub = self.stub\n\n    if not stub:\n        return\n\n    inst_id = instance.get(\"instance_id\") or instance.get(\"uuid\")  # legacy\n    if not inst_id:\n        log.warning(\"No instance identifier for {}\".format(instance))\n        return\n\n    stub.remove_instance(inst_id)\n\n    if instance.get(\"members\"):\n        item = stub.get_item(instance[\"members\"][0])\n        if item:\n            stub.rename_item(item.id,\n                             item.name.replace(stub.PUBLISH_ICON, ''))\n</code></pre>"},{"location":"autoapi/client/ayon_premiere/api/index.html#client.ayon_premiere.api.containerise","title":"<code>containerise(name, namespace, bin_item, context, loader=None, imported_composition=None)</code>","text":"<p>Containerisation enables a tracking of version, author and origin for loaded assets.</p> <p>Creates dictionary payloads that gets saved into file metadata. Each container contains of who loaded (loader) and members (single or multiple in case of background).</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name of resulting assembly</p> required <code>namespace</code> <code>str</code> <p>Namespace under which to host container</p> required <code>bin_item</code> <code>PPROItem</code> <p>Bin to containerise</p> required <code>context</code> <code>dict</code> <p>Asset information</p> required <code>loader</code> <code>str</code> <p>Name of loader used to produce this container.</p> <code>None</code> <code>imported_composition</code> <code>str</code> <p>loaded composition from AE</p> <code>None</code> <p>Returns:</p> Name Type Description <code>container</code> <code>str</code> <p>Name of container assembly</p> Source code in <code>client/ayon_premiere/api/pipeline.py</code> <pre><code>def containerise(\n    name,\n    namespace,\n    bin_item,\n    context,\n    loader=None,\n    imported_composition=None\n):\n    \"\"\"\n    Containerisation enables a tracking of version, author and origin\n    for loaded assets.\n\n    Creates dictionary payloads that gets saved into file metadata. Each\n    container contains of who loaded (loader) and members (single or multiple\n    in case of background).\n\n    Arguments:\n        name (str): Name of resulting assembly\n        namespace (str): Namespace under which to host container\n        bin_item (PPROItem): Bin to containerise\n        context (dict): Asset information\n        loader (str, optional): Name of loader used to produce this container.\n        imported_composition (str, optional): loaded composition from AE\n\n    Returns:\n        container (str): Name of container assembly\n    \"\"\"\n    data = {\n        \"schema\": \"openpype:container-2.0\",\n        \"id\": AYON_CONTAINER_ID,\n        \"name\": name,\n        \"namespace\": namespace,\n        \"loader\": str(loader),\n        \"representation\": context[\"representation\"][\"id\"],\n        \"members\": [bin_item.id]\n    }\n    if imported_composition:\n        data[\"imported_composition\"] = imported_composition\n\n    stub = get_stub()\n    stub.imprint(bin_item.id, data)\n\n    return bin_item\n</code></pre>"},{"location":"autoapi/client/ayon_premiere/api/index.html#client.ayon_premiere.api.get_stub","title":"<code>get_stub()</code>","text":"<pre><code>Convenience function to get server RPC stub to call methods directed\nfor host (Premiere).\nIt expects already created connection, started from client.\nCurrently created when panel is opened (PS: Window&gt;Extensions&gt;AYON)\n</code></pre> <p>:return:  where functions could be called from Source code in <code>client/ayon_premiere/api/ws_stub.py</code> <pre><code>def get_stub():\n    \"\"\"\n        Convenience function to get server RPC stub to call methods directed\n        for host (Premiere).\n        It expects already created connection, started from client.\n        Currently created when panel is opened (PS: Window&gt;Extensions&gt;AYON)\n    :return: &lt;PremiereServerStub&gt; where functions could be called from\n    \"\"\"\n    stub = PremiereServerStub()\n    if not stub.client:\n        raise ConnectionNotEstablishedYet(\"Connection is not created yet\")\n\n    return stub\n</code></pre>"},{"location":"autoapi/client/ayon_premiere/api/index.html#client.ayon_premiere.api.ls","title":"<code>ls()</code>","text":"<p>Yields containers from active Premiere document.</p> <p>This is the host-equivalent of api.ls(), but instead of listing assets on disk, it lists assets already loaded in AE; once loaded they are called 'containers'. Used in Manage tool.</p> <p>Containers could be on multiple levels, single images/videos/was as a FootageItem, or multiple items - backgrounds (folder with automatically created composition and all imported layers).</p> <p>Yields:</p> Name Type Description <code>dict</code> <p>container</p> Source code in <code>client/ayon_premiere/api/pipeline.py</code> <pre><code>def ls():\n    \"\"\"Yields containers from active Premiere document.\n\n    This is the host-equivalent of api.ls(), but instead of listing\n    assets on disk, it lists assets already loaded in AE; once loaded\n    they are called 'containers'. Used in Manage tool.\n\n    Containers could be on multiple levels, single images/videos/was as a\n    FootageItem, or multiple items - backgrounds (folder with automatically\n    created composition and all imported layers).\n\n    Yields:\n        dict: container\n\n    \"\"\"\n    try:\n        stub = get_stub()  # only after Premiere is up\n    except ConnectionNotEstablishedYet:\n        print(\"Not connected yet, ignoring\")\n        return\n\n    project_metadata = stub.get_metadata()\n    for item in stub.get_items(bins=True, sequences=False, footages=False):\n        metadata = stub.get_item_metadata(item, project_metadata)\n        # Skip non AYON item.\n        if not metadata:\n            continue\n\n        is_loaded_container = \"container\" not in metadata[\"id\"]\n        if is_loaded_container:\n            continue\n\n        # Append transient data\n        metadata[\"objectName\"] = item.name.replace(stub.LOADED_ICON, \"\")\n        metadata[\"bin\"] = item\n        yield metadata\n</code></pre>"},{"location":"autoapi/client/ayon_premiere/api/launch_logic.html","title":"launch_logic","text":""},{"location":"autoapi/client/ayon_premiere/api/launch_logic.html#client.ayon_premiere.api.launch_logic.PremiereRoute","title":"<code>PremiereRoute</code>","text":"<p>               Bases: <code>WebSocketRoute</code></p> <p>One route, mimicking external application (like Harmony, etc). All functions could be called from client. 'do_notify' function calls function on the client - mimicking     notification after long running job on the server or similar</p> Source code in <code>client/ayon_premiere/api/launch_logic.py</code> <pre><code>class PremiereRoute(WebSocketRoute):\n    \"\"\"\n        One route, mimicking external application (like Harmony, etc).\n        All functions could be called from client.\n        'do_notify' function calls function on the client - mimicking\n            notification after long running job on the server or similar\n    \"\"\"\n    instance = None\n\n    def init(self, **kwargs):\n        # Python __init__ must be return \"self\".\n        # This method might return anything.\n        log.debug(\"someone called Premiere route\")\n        self.instance = self\n        return kwargs\n\n    # server functions\n    async def ping(self):\n        log.debug(\"someone called Premiere route ping\")\n\n    # This method calls function on the client side\n    # client functions\n    async def set_context(self, project, folder, task):\n        \"\"\"\n            Sets 'project', 'folder' and 'task' to envs, eg. setting context\n\n            Args:\n                project (str)\n                folder (str)\n                task (str)\n        \"\"\"\n        log.info(\"Setting context change\")\n        log.info(\"project {} folder {} \".format(project, folder))\n        if project:\n            os.environ[\"AYON_PROJECT_NAME\"] = project\n        if folder:\n            os.environ[\"AYON_FOLDER_PATH\"] = folder\n        if task:\n            os.environ[\"AYON_TASK_NAME\"] = task\n\n    async def read(self):\n        log.debug(\"premiere.read client calls server server calls \"\n                  \"premiere client\")\n        return await self.socket.call('premiere.read')\n\n    # panel routes for tools\n    async def workfiles_route(self):\n        log.info(\"workfiles__route\")\n        self._tool_route(\"workfiles\")\n\n    async def loader_route(self):\n        self._tool_route(\"loader\")\n\n    async def publish_route(self):\n        self._tool_route(\"publisher\")\n\n    async def sceneinventory_route(self):\n        self._tool_route(\"sceneinventory\")\n\n    async def setresolution_route(self):\n        self._settings_route(False, True)\n\n    async def setframes_route(self):\n        self._settings_route(True, False)\n\n    async def setall_route(self):\n        self._settings_route(True, True)\n\n    async def experimental_tools_route(self):\n        self._tool_route(\"experimental_tools\")\n\n    def _tool_route(self, _tool_name):\n        \"\"\"The address accessed when clicking on the buttons.\"\"\"\n\n        partial_method = functools.partial(show_tool_by_name,\n                                           _tool_name)\n\n        ProcessLauncher.execute_in_main_thread(partial_method)\n\n        # Required return statement.\n        return \"nothing\"\n\n    def _settings_route(self, frames, resolution):\n        partial_method = functools.partial(set_settings,\n                                           frames,\n                                           resolution)\n\n        ProcessLauncher.execute_in_main_thread(partial_method)\n\n        # Required return statement.\n        return \"nothing\"\n\n    def create_placeholder_route(self):\n        from ayon_premiere.api.workfile_template_builder import \\\n            create_placeholder\n        partial_method = functools.partial(create_placeholder)\n\n        ProcessLauncher.execute_in_main_thread(partial_method)\n\n        # Required return statement.\n        return \"nothing\"\n\n    def update_placeholder_route(self):\n        from ayon_premiere.api.workfile_template_builder import \\\n            update_placeholder\n        partial_method = functools.partial(update_placeholder)\n\n        ProcessLauncher.execute_in_main_thread(partial_method)\n\n        # Required return statement.\n        return \"nothing\"\n\n    def build_workfile_template_route(self):\n        from ayon_premiere.api.workfile_template_builder import \\\n            build_workfile_template\n        partial_method = functools.partial(build_workfile_template)\n\n        ProcessLauncher.execute_in_main_thread(partial_method)\n\n        # Required return statement.\n        return \"nothing\"\n</code></pre>"},{"location":"autoapi/client/ayon_premiere/api/launch_logic.html#client.ayon_premiere.api.launch_logic.PremiereRoute.set_context","title":"<code>set_context(project, folder, task)</code>  <code>async</code>","text":"<p>Sets 'project', 'folder' and 'task' to envs, eg. setting context</p> Source code in <code>client/ayon_premiere/api/launch_logic.py</code> <pre><code>async def set_context(self, project, folder, task):\n    \"\"\"\n        Sets 'project', 'folder' and 'task' to envs, eg. setting context\n\n        Args:\n            project (str)\n            folder (str)\n            task (str)\n    \"\"\"\n    log.info(\"Setting context change\")\n    log.info(\"project {} folder {} \".format(project, folder))\n    if project:\n        os.environ[\"AYON_PROJECT_NAME\"] = project\n    if folder:\n        os.environ[\"AYON_FOLDER_PATH\"] = folder\n    if task:\n        os.environ[\"AYON_TASK_NAME\"] = task\n</code></pre>"},{"location":"autoapi/client/ayon_premiere/api/launch_logic.html#client.ayon_premiere.api.launch_logic.ProcessLauncher","title":"<code>ProcessLauncher</code>","text":"<p>               Bases: <code>QObject</code></p> <p>Launches webserver, connects to it, runs main thread.</p> Source code in <code>client/ayon_premiere/api/launch_logic.py</code> <pre><code>class ProcessLauncher(QtCore.QObject):\n    \"\"\"Launches webserver, connects to it, runs main thread.\"\"\"\n    route_name = \"Premiere\"\n    _main_thread_callbacks = collections.deque()\n\n    def __init__(self, subprocess_args):\n        self._subprocess_args = subprocess_args\n        self._log = None\n\n        super(ProcessLauncher, self).__init__()\n\n        # Keep track if launcher was alreadu started\n        self._started = False\n\n        self._process = None\n        self._websocket_server = None\n\n        start_process_timer = QtCore.QTimer()\n        start_process_timer.setInterval(100)\n\n        loop_timer = QtCore.QTimer()\n        loop_timer.setInterval(200)\n\n        start_process_timer.timeout.connect(self._on_start_process_timer)\n        loop_timer.timeout.connect(self._on_loop_timer)\n\n        self._start_process_timer = start_process_timer\n        self._loop_timer = loop_timer\n\n    @property\n    def log(self):\n        if self._log is None:\n            self._log = Logger.get_logger(\"{}-launcher\".format(\n                self.route_name))\n        return self._log\n\n    @property\n    def websocket_server_is_running(self):\n        if self._websocket_server is not None:\n            return self._websocket_server.is_running\n        return False\n\n    @property\n    def is_process_running(self):\n        if self._process is not None:\n            return self._process.poll() is None\n        return False\n\n    @property\n    def is_host_connected(self):\n        \"\"\"Returns True if connected, False if app is not running at all.\"\"\"\n        if not self.is_process_running:\n            return False\n\n        try:\n\n            _stub = get_stub()\n            if _stub:\n                return True\n        except Exception:\n            pass\n\n        return None\n\n    @classmethod\n    def execute_in_main_thread(cls, callback):\n        cls._main_thread_callbacks.append(callback)\n\n    def start(self):\n        if self._started:\n            return\n        self.log.info(\"Started launch logic of Premiere\")\n        self._started = True\n        self._start_process_timer.start()\n\n    def exit(self):\n        \"\"\" Exit whole application. \"\"\"\n        if self._start_process_timer.isActive():\n            self._start_process_timer.stop()\n        if self._loop_timer.isActive():\n            self._loop_timer.stop()\n\n        if self._websocket_server is not None:\n            self._websocket_server.stop()\n\n        if self._process:\n            self._process.kill()\n            self._process.wait()\n\n        QtCore.QCoreApplication.exit()\n\n    def _on_loop_timer(self):\n        # TODO find better way and catch errors\n        # Run only callbacks that are in queue at the moment\n        cls = self.__class__\n        for _ in range(len(cls._main_thread_callbacks)):\n            if cls._main_thread_callbacks:\n                callback = cls._main_thread_callbacks.popleft()\n                callback()\n\n        if not self.is_process_running:\n            self.log.info(\"Host process is not running. Closing\")\n            self.exit()\n\n        elif not self.websocket_server_is_running:\n            self.log.info(\"Websocket server is not running. Closing\")\n            self.exit()\n\n    def _on_start_process_timer(self):\n        # TODO add try except validations for each part in this method\n        # Start server as first thing\n        if self._websocket_server is None:\n            self._init_server()\n            return\n\n        # TODO add waiting time\n        # Wait for webserver\n        if not self.websocket_server_is_running:\n            return\n\n        # Start application process\n        if self._process is None:\n            self._start_process()\n            self.log.info(\"Waiting for host to connect\")\n            return\n\n        # TODO add waiting time\n        # Wait until host is connected\n        if self.is_host_connected:\n            self._start_process_timer.stop()\n            self._loop_timer.start()\n        elif (\n            not self.is_process_running\n            or not self.websocket_server_is_running\n        ):\n            self.exit()\n\n    def _init_server(self):\n        if self._websocket_server is not None:\n            return\n\n        self.log.debug(\n            \"Initialization of websocket server for host communication\"\n        )\n\n        self._websocket_server = websocket_server = WebServerTool()\n        if websocket_server.port_occupied(\n            websocket_server.host_name,\n            websocket_server.port\n        ):\n            self.log.info(\n                \"Server already running, sending actual context and exit.\"\n            )\n            asyncio.run(websocket_server.send_context_change(self.route_name))\n            self.exit()\n            return\n\n        # Add Websocket route\n        websocket_server.add_route(\"*\", \"/ws/\", WebSocketAsync)\n        # Add after effects route to websocket handler\n\n        print(\"Adding {} route\".format(self.route_name))\n        WebSocketAsync.add_route(\n            self.route_name, PremiereRoute\n        )\n        self.log.info(\"Starting websocket server for host communication\")\n        websocket_server.start_server()\n\n    def _start_process(self):\n        if self._process is not None:\n            return\n        self.log.info(\"Starting host process\")\n        try:\n            self._process = subprocess.Popen(\n                self._subprocess_args,\n                stdout=subprocess.DEVNULL,\n                stderr=subprocess.DEVNULL\n            )\n        except Exception:\n            self.log.info(\"exce\", exc_info=True)\n            self.exit()\n</code></pre>"},{"location":"autoapi/client/ayon_premiere/api/launch_logic.html#client.ayon_premiere.api.launch_logic.ProcessLauncher.is_host_connected","title":"<code>is_host_connected</code>  <code>property</code>","text":"<p>Returns True if connected, False if app is not running at all.</p>"},{"location":"autoapi/client/ayon_premiere/api/launch_logic.html#client.ayon_premiere.api.launch_logic.ProcessLauncher.exit","title":"<code>exit()</code>","text":"<p>Exit whole application.</p> Source code in <code>client/ayon_premiere/api/launch_logic.py</code> <pre><code>def exit(self):\n    \"\"\" Exit whole application. \"\"\"\n    if self._start_process_timer.isActive():\n        self._start_process_timer.stop()\n    if self._loop_timer.isActive():\n        self._loop_timer.stop()\n\n    if self._websocket_server is not None:\n        self._websocket_server.stop()\n\n    if self._process:\n        self._process.kill()\n        self._process.wait()\n\n    QtCore.QCoreApplication.exit()\n</code></pre>"},{"location":"autoapi/client/ayon_premiere/api/launch_logic.html#client.ayon_premiere.api.launch_logic.main","title":"<code>main(*subprocess_args)</code>","text":"<p>Main entrypoint to AE launching, called from pre hook.</p> Source code in <code>client/ayon_premiere/api/launch_logic.py</code> <pre><code>def main(*subprocess_args):\n    \"\"\"Main entrypoint to AE launching, called from pre hook.\"\"\"\n    sys.excepthook = safe_excepthook\n\n    from ayon_premiere.api import PremiereHost\n\n    host = PremiereHost()\n    install_host(host)\n\n    os.environ[\"AYON_LOG_NO_COLORS\"] = \"0\"\n    app = get_ayon_qt_app()\n    app.setQuitOnLastWindowClosed(False)\n\n    launcher = ProcessLauncher(subprocess_args)\n    launcher.start()\n\n    env_workfiles_on_launch = os.getenv(\"AYON_PREMIERE_WORKFILES_ON_LAUNCH\")\n    workfiles_on_launch = env_value_to_bool(value=env_workfiles_on_launch)\n\n    if is_in_tests():\n        manager = AddonsManager()\n        premiere_addon = manager[\"premiere\"]\n\n        launcher.execute_in_main_thread(\n            functools.partial(\n                premiere_addon.publish_in_test,\n                log,\n                \"ClosePPRO\",\n            )\n        )\n\n    elif workfiles_on_launch:\n        save = False\n        if os.getenv(\"WORKFILES_SAVE_AS\"):\n            save = True\n\n        launcher.execute_in_main_thread(\n            lambda: host_tools.show_tool_by_name(\"workfiles\", save=save)\n        )\n\n    sys.exit(app.exec_())\n</code></pre>"},{"location":"autoapi/client/ayon_premiere/api/launch_script.html","title":"launch_script","text":"<p>Script wraps launch mechanism of Premiere implementations.</p> <p>Arguments passed to the script are passed to launch function in host implementation. In all cases requires host app executable and may contain workfile or others.</p>"},{"location":"autoapi/client/ayon_premiere/api/launch_script.html#client.ayon_premiere.api.launch_script.on_invalid_args","title":"<code>on_invalid_args(script_not_found)</code>","text":"<p>Show to user message box saying that something went wrong.</p> <p>Tell user that arguments to launch implementation are invalid with arguments details.</p> <p>Parameters:</p> Name Type Description Default <code>script_not_found</code> <code>bool</code> <p>Use different message based on this value.</p> required Source code in <code>client/ayon_premiere/api/launch_script.py</code> <pre><code>def on_invalid_args(script_not_found):\n    \"\"\"Show to user message box saying that something went wrong.\n\n    Tell user that arguments to launch implementation are invalid with\n    arguments details.\n\n    Args:\n        script_not_found (bool): Use different message based on this value.\n    \"\"\"\n\n    title = \"Invalid arguments\"\n    joined_args = \", \".join(\"\\\"{}\\\"\".format(arg) for arg in sys.argv)\n    if script_not_found:\n        submsg = \"Where couldn't find script path:\\n\\\"{}\\\"\"\n    else:\n        submsg = \"Expected Host executable after script path:\\n\\\"{}\\\"\"\n\n    message = \"BUG: Got invalid arguments so can't launch Host application.\"\n    detail_message = \"Process was launched with arguments:\\n{}\\n\\n{}\".format(\n        joined_args,\n        submsg.format(CURRENT_FILE)\n    )\n\n    show_error_messagebox(title, message, detail_message)\n</code></pre>"},{"location":"autoapi/client/ayon_premiere/api/launch_script.html#client.ayon_premiere.api.launch_script.show_error_messagebox","title":"<code>show_error_messagebox(title, message, detail_message=None)</code>","text":"<p>Function will show message and process ends after closing it.</p> Source code in <code>client/ayon_premiere/api/launch_script.py</code> <pre><code>def show_error_messagebox(title, message, detail_message=None):\n    \"\"\"Function will show message and process ends after closing it.\"\"\"\n    from qtpy import QtWidgets, QtCore\n    from ayon_core import style\n\n    app = QtWidgets.QApplication([])\n    app.setStyleSheet(style.load_stylesheet())\n\n    msgbox = QtWidgets.QMessageBox()\n    msgbox.setWindowTitle(title)\n    msgbox.setText(message)\n\n    if detail_message:\n        msgbox.setDetailedText(detail_message)\n\n    msgbox.setWindowModality(QtCore.Qt.ApplicationModal)\n    msgbox.show()\n\n    sys.exit(app.exec_())\n</code></pre>"},{"location":"autoapi/client/ayon_premiere/api/lib.html","title":"lib","text":""},{"location":"autoapi/client/ayon_premiere/api/lib.html#client.ayon_premiere.api.lib.get_background_layers","title":"<code>get_background_layers(file_url)</code>","text":"<p>Pulls file name from background json file, enrich with folder url for AE to be able import files.</p> <p>Order is important, follows order in json.</p> <p>Parameters:</p> Name Type Description Default <code>file_url</code> <code>str</code> <p>abs url of background json</p> required <p>Returns:</p> Type Description <code>list</code> <p>of abs paths to images</p> Source code in <code>client/ayon_premiere/api/lib.py</code> <pre><code>def get_background_layers(file_url):\n    \"\"\"\n        Pulls file name from background json file, enrich with folder url for\n        AE to be able import files.\n\n        Order is important, follows order in json.\n\n        Args:\n            file_url (str): abs url of background json\n\n        Returns:\n            (list): of abs paths to images\n    \"\"\"\n    with open(file_url) as json_file:\n        data = json.load(json_file)\n\n    layers = list()\n    bg_folder = os.path.dirname(file_url)\n    for child in data['children']:\n        if child.get(\"filename\"):\n            layers.append(os.path.join(bg_folder, child.get(\"filename\")).\n                          replace(\"\\\\\", \"/\"))\n        else:\n            for layer in child['children']:\n                if layer.get(\"filename\"):\n                    layers.append(os.path.join(bg_folder,\n                                               layer.get(\"filename\")).\n                                  replace(\"\\\\\", \"/\"))\n    return layers\n</code></pre>"},{"location":"autoapi/client/ayon_premiere/api/lib.html#client.ayon_premiere.api.lib.get_folder_settings","title":"<code>get_folder_settings(folder_entity)</code>","text":"<p>Get settings of current folder.</p> <p>Returns:</p> Name Type Description <code>dict</code> <p>Scene data.</p> Source code in <code>client/ayon_premiere/api/lib.py</code> <pre><code>def get_folder_settings(folder_entity):\n    \"\"\"Get settings of current folder.\n\n    Returns:\n        dict: Scene data.\n\n    \"\"\"\n    folder_attributes = folder_entity[\"attrib\"]\n    fps = folder_attributes.get(\"fps\", 0)\n    frame_start = folder_attributes.get(\"frameStart\", 0)\n    frame_end = folder_attributes.get(\"frameEnd\", 0)\n    handle_start = folder_attributes.get(\"handleStart\", 0)\n    handle_end = folder_attributes.get(\"handleEnd\", 0)\n    resolution_width = folder_attributes.get(\"resolutionWidth\", 0)\n    resolution_height = folder_attributes.get(\"resolutionHeight\", 0)\n    duration = (frame_end - frame_start + 1) + handle_start + handle_end\n\n    return {\n        \"fps\": fps,\n        \"frameStart\": frame_start,\n        \"frameEnd\": frame_end,\n        \"handleStart\": handle_start,\n        \"handleEnd\": handle_end,\n        \"resolutionWidth\": resolution_width,\n        \"resolutionHeight\": resolution_height,\n        \"duration\": duration\n    }\n</code></pre>"},{"location":"autoapi/client/ayon_premiere/api/lib.html#client.ayon_premiere.api.lib.get_unique_bin_name","title":"<code>get_unique_bin_name(bin_names, new_name)</code>","text":"<p>Gets all bin names and if 'name' is present in them, increases suffix by 1 (eg. creates unique sequence name - for Loader)</p> <p>Parameters:</p> Name Type Description Default <code>bins</code> <code>list[str]</code> <p>of strings, names only</p> required <code>new_name</code> <code>string</code> <p>checked value</p> required <p>Returns:</p> Type Description <code>string</code> <p>name_00X (without version)</p> Source code in <code>client/ayon_premiere/api/lib.py</code> <pre><code>def get_unique_bin_name(bin_names, new_name):\n    \"\"\"Gets all bin names and if 'name' is present in them, increases\n    suffix by 1 (eg. creates unique sequence name - for Loader)\n\n    Args:\n        bins (list[str]): of strings, names only\n        new_name (string):  checked value\n\n    Returns:\n        (string): name_00X (without version)\n    \"\"\"\n    name_occurences = {}\n    for bin_name in bin_names:\n        name, _, ordinal_number = bin_name.rpartition('_')\n        name_occurences[name] = ordinal_number\n    occurrence = name_occurences.get(new_name, 0)\n    try:\n        occurrence = int(occurrence)\n    except TypeError:\n        occurrence = 0\n\n    return \"{}_{:0&gt;3d}\".format(new_name, occurrence + 1)\n</code></pre>"},{"location":"autoapi/client/ayon_premiere/api/lib.html#client.ayon_premiere.api.lib.maintained_selection","title":"<code>maintained_selection()</code>","text":"<p>Maintain selection during context.</p> Source code in <code>client/ayon_premiere/api/lib.py</code> <pre><code>@contextlib.contextmanager\ndef maintained_selection():\n    \"\"\"Maintain selection during context.\"\"\"\n    selection = get_stub().get_selected_items(True, False, False)\n    try:\n        yield selection\n    finally:\n        pass\n</code></pre>"},{"location":"autoapi/client/ayon_premiere/api/lib.html#client.ayon_premiere.api.lib.publish_in_test","title":"<code>publish_in_test(log, close_plugin_name=None)</code>","text":"<p>Loops through all plugins, logs to console. Used for tests.</p> <p>Parameters:</p> Name Type Description Default <code>close_plugin_name</code> <code>Optional[str]</code> <p>Name of plugin with responsibility to close application.</p> <code>None</code> Source code in <code>client/ayon_premiere/api/lib.py</code> <pre><code>def publish_in_test(log, close_plugin_name=None):\n    \"\"\"Loops through all plugins, logs to console. Used for tests.\n\n    Args:\n        log (Logger)\n        close_plugin_name (Optional[str]): Name of plugin with responsibility\n            to close application.\n    \"\"\"\n\n    # Error exit as soon as any error occurs.\n    error_format = \"Failed {plugin.__name__}: {error} -- {error.traceback}\"\n    close_plugin = find_close_plugin(close_plugin_name, log)\n\n    for result in pyblish.util.publish_iter():\n        for record in result[\"records\"]:\n            # Why do we log again? pyblish logger is logging to stdout...\n            log.info(\"{}: {}\".format(result[\"plugin\"].label, record.msg))\n\n        if not result[\"error\"]:\n            continue\n\n        # QUESTION We don't break on error?\n        error_message = error_format.format(**result)\n        log.error(error_message)\n        if close_plugin:  # close host app explicitly after error\n            context = pyblish.api.Context()\n            try:\n                close_plugin().process(context)\n            except Exception as exp:\n                print(exp)\n</code></pre>"},{"location":"autoapi/client/ayon_premiere/api/lib.html#client.ayon_premiere.api.lib.set_settings","title":"<code>set_settings(frames, resolution, comp_ids=None, print_msg=True)</code>","text":"<p>Sets number of frames and resolution to selected comps.</p> <p>Parameters:</p> Name Type Description Default <code>frames</code> <code>bool</code> <p>True if set frame info</p> required <code>resolution</code> <code>bool</code> <p>True if set resolution</p> required <code>comp_ids</code> <code>list</code> <p>specific composition ids, if empty it tries to look for currently selected</p> <code>None</code> <code>print_msg</code> <code>bool</code> <p>True throw JS alert with msg</p> <code>True</code> Source code in <code>client/ayon_premiere/api/lib.py</code> <pre><code>def set_settings(frames, resolution, comp_ids=None, print_msg=True):\n    \"\"\"Sets number of frames and resolution to selected comps.\n\n    Args:\n        frames (bool): True if set frame info\n        resolution (bool): True if set resolution\n        comp_ids (list): specific composition ids, if empty\n            it tries to look for currently selected\n        print_msg (bool): True throw JS alert with msg\n    \"\"\"\n    frame_start = frames_duration = fps = width = height = None\n    current_context = get_current_context()\n\n    folder_entity = ayon_api.get_folder_by_path(\n        current_context[\"project_name\"],\n        current_context[\"folder_path\"]\n    )\n    settings = get_folder_settings(folder_entity)\n\n    msg = ''\n    if frames:\n        frame_start = settings[\"frameStart\"] - settings[\"handleStart\"]\n        frames_duration = settings[\"duration\"]\n        fps = settings[\"fps\"]\n        msg += f\"frame start:{frame_start}, duration:{frames_duration}, \"\\\n               f\"fps:{fps}\"\n    if resolution:\n        width = settings[\"resolutionWidth\"]\n        height = settings[\"resolutionHeight\"]\n        msg += f\"width:{width} and height:{height}\"\n\n    stub = get_stub()\n    if not comp_ids:\n        comps = stub.get_selected_items(True, False, False)\n        comp_ids = [comp.id for comp in comps]\n    if not comp_ids:\n        stub.print_msg(\"Select at least one composition to apply settings.\")\n        return\n\n    for comp_id in comp_ids:\n        msg = f\"Setting for comp {comp_id} \" + msg\n        log.debug(msg)\n        stub.set_comp_properties(comp_id, frame_start, frames_duration,\n                                 fps, width, height)\n        if print_msg:\n            stub.print_msg(msg)\n</code></pre>"},{"location":"autoapi/client/ayon_premiere/api/pipeline.html","title":"pipeline","text":""},{"location":"autoapi/client/ayon_premiere/api/pipeline.html#client.ayon_premiere.api.pipeline.PremiereHost","title":"<code>PremiereHost</code>","text":"<p>               Bases: <code>HostBase</code>, <code>IWorkfileHost</code>, <code>ILoadHost</code>, <code>IPublishHost</code></p> Source code in <code>client/ayon_premiere/api/pipeline.py</code> <pre><code>class PremiereHost(HostBase, IWorkfileHost, ILoadHost, IPublishHost):\n    name = \"premiere\"\n\n    def __init__(self):\n        self._stub = None\n        super().__init__()\n\n    @property\n    def stub(self):\n        \"\"\"\n            Handle pulling stub from PS to run operations on host\n        Returns:\n            (AEServerStub) or None\n        \"\"\"\n        if self._stub:\n            return self._stub\n\n        try:\n            stub = get_stub()  # only after Photoshop is up\n        except ConnectionNotEstablishedYet:\n            print(\"Not connected yet, ignoring\")\n            return\n\n        self._stub = stub\n        return self._stub\n\n    def install(self):\n        print(\"Installing AYON config...\")\n\n        pyblish.api.register_host(self.name)\n        pyblish.api.register_plugin_path(PUBLISH_PATH)\n\n        register_loader_plugin_path(LOAD_PATH)\n        register_creator_plugin_path(CREATE_PATH)\n        register_workfile_build_plugin_path(WORKFILE_BUILD_PATH)\n\n        register_event_callback(\"application.launched\", application_launch)\n\n    def get_workfile_extensions(self):\n        return [\".prproj\"]\n\n    def save_workfile(self, dst_path=None):\n        self.stub.saveAs(dst_path, True)\n\n    def open_workfile(self, filepath):\n        self.stub.open(filepath)\n\n        return True\n\n    def get_current_workfile(self):\n        try:\n            full_name = get_stub().get_active_document_full_name()\n            if full_name and full_name != \"null\":\n                return os.path.normpath(full_name).replace(\"\\\\\", \"/\")\n        except ValueError:\n            print(\"Nothing opened\")\n            pass\n\n        return None\n\n    def get_containers(self):\n        return ls()\n\n    def get_context_data(self):\n        meta = self.stub.get_metadata()\n        for item in meta:\n            if item.get(\"id\") == \"publish_context\":\n                item.pop(\"id\")\n                return item\n\n        return {}\n\n    def update_context_data(self, data, changes):\n        item = data\n        item[\"id\"] = \"publish_context\"\n        self.stub.imprint(item[\"id\"], item)\n\n    # created instances section\n    def list_instances(self):\n        \"\"\"List all created instances from current workfile which\n        will be published.\n\n        Pulls from File &gt; File Info\n\n        For SubsetManager\n\n        Returns:\n            (list) of dictionaries matching instances format\n        \"\"\"\n        stub = self.stub\n        if not stub:\n            return []\n\n        instances = []\n        layers_meta = stub.get_metadata()\n\n        for instance in layers_meta:\n            if instance.get(\"id\") in {\n                AYON_INSTANCE_ID, AVALON_INSTANCE_ID\n            }:\n                instances.append(instance)\n        return instances\n\n    def remove_instance(self, instance):\n        \"\"\"Remove instance from current workfile metadata.\n\n        Updates metadata of current file in File &gt; File Info and removes\n        icon highlight on group layer.\n\n        For SubsetManager\n\n        Args:\n            instance (dict): instance representation from subsetmanager model\n        \"\"\"\n        stub = self.stub\n\n        if not stub:\n            return\n\n        inst_id = instance.get(\"instance_id\") or instance.get(\"uuid\")  # legacy\n        if not inst_id:\n            log.warning(\"No instance identifier for {}\".format(instance))\n            return\n\n        stub.remove_instance(inst_id)\n\n        if instance.get(\"members\"):\n            item = stub.get_item(instance[\"members\"][0])\n            if item:\n                stub.rename_item(item.id,\n                                 item.name.replace(stub.PUBLISH_ICON, ''))\n</code></pre>"},{"location":"autoapi/client/ayon_premiere/api/pipeline.html#client.ayon_premiere.api.pipeline.PremiereHost.stub","title":"<code>stub</code>  <code>property</code>","text":"<pre><code>Handle pulling stub from PS to run operations on host\n</code></pre> <p>Returns:     (AEServerStub) or None</p>"},{"location":"autoapi/client/ayon_premiere/api/pipeline.html#client.ayon_premiere.api.pipeline.PremiereHost.list_instances","title":"<code>list_instances()</code>","text":"<p>List all created instances from current workfile which will be published.</p> <p>Pulls from File &gt; File Info</p> <p>For SubsetManager</p> <p>Returns:</p> Type Description <p>(list) of dictionaries matching instances format</p> Source code in <code>client/ayon_premiere/api/pipeline.py</code> <pre><code>def list_instances(self):\n    \"\"\"List all created instances from current workfile which\n    will be published.\n\n    Pulls from File &gt; File Info\n\n    For SubsetManager\n\n    Returns:\n        (list) of dictionaries matching instances format\n    \"\"\"\n    stub = self.stub\n    if not stub:\n        return []\n\n    instances = []\n    layers_meta = stub.get_metadata()\n\n    for instance in layers_meta:\n        if instance.get(\"id\") in {\n            AYON_INSTANCE_ID, AVALON_INSTANCE_ID\n        }:\n            instances.append(instance)\n    return instances\n</code></pre>"},{"location":"autoapi/client/ayon_premiere/api/pipeline.html#client.ayon_premiere.api.pipeline.PremiereHost.remove_instance","title":"<code>remove_instance(instance)</code>","text":"<p>Remove instance from current workfile metadata.</p> <p>Updates metadata of current file in File &gt; File Info and removes icon highlight on group layer.</p> <p>For SubsetManager</p> <p>Parameters:</p> Name Type Description Default <code>instance</code> <code>dict</code> <p>instance representation from subsetmanager model</p> required Source code in <code>client/ayon_premiere/api/pipeline.py</code> <pre><code>def remove_instance(self, instance):\n    \"\"\"Remove instance from current workfile metadata.\n\n    Updates metadata of current file in File &gt; File Info and removes\n    icon highlight on group layer.\n\n    For SubsetManager\n\n    Args:\n        instance (dict): instance representation from subsetmanager model\n    \"\"\"\n    stub = self.stub\n\n    if not stub:\n        return\n\n    inst_id = instance.get(\"instance_id\") or instance.get(\"uuid\")  # legacy\n    if not inst_id:\n        log.warning(\"No instance identifier for {}\".format(instance))\n        return\n\n    stub.remove_instance(inst_id)\n\n    if instance.get(\"members\"):\n        item = stub.get_item(instance[\"members\"][0])\n        if item:\n            stub.rename_item(item.id,\n                             item.name.replace(stub.PUBLISH_ICON, ''))\n</code></pre>"},{"location":"autoapi/client/ayon_premiere/api/pipeline.html#client.ayon_premiere.api.pipeline.application_launch","title":"<code>application_launch()</code>","text":"<p>Triggered after start of app</p> Source code in <code>client/ayon_premiere/api/pipeline.py</code> <pre><code>def application_launch():\n    \"\"\"Triggered after start of app\"\"\"\n    check_inventory()\n</code></pre>"},{"location":"autoapi/client/ayon_premiere/api/pipeline.html#client.ayon_premiere.api.pipeline.cache_and_get_instances","title":"<code>cache_and_get_instances(creator)</code>","text":"<p>Cache instances in shared data.</p> <p>Storing all instances as a list as legacy instances might be still present. Args:     creator (Creator): Plugin which would like to get instances from host. Returns:     List[]: list of all instances stored in metadata</p> Source code in <code>client/ayon_premiere/api/pipeline.py</code> <pre><code>def cache_and_get_instances(creator):\n    \"\"\"Cache instances in shared data.\n\n    Storing all instances as a list as legacy instances might be still present.\n    Args:\n        creator (Creator): Plugin which would like to get instances from host.\n    Returns:\n        List[]: list of all instances stored in metadata\n    \"\"\"\n    shared_key = \"ayon.premiere.instances\"\n    if shared_key not in creator.collection_shared_data:\n        creator.collection_shared_data[shared_key] = \\\n            creator.host.list_instances()\n    return creator.collection_shared_data[shared_key]\n</code></pre>"},{"location":"autoapi/client/ayon_premiere/api/pipeline.html#client.ayon_premiere.api.pipeline.check_inventory","title":"<code>check_inventory()</code>","text":"<p>Checks loaded containers if they are of highest version</p> Source code in <code>client/ayon_premiere/api/pipeline.py</code> <pre><code>def check_inventory():\n    \"\"\"Checks loaded containers if they are of highest version\"\"\"\n    if not any_outdated_containers():\n        return\n\n    # Warn about outdated containers.\n    _app = get_ayon_qt_app()\n\n    message_box = QtWidgets.QMessageBox()\n    message_box.setIcon(QtWidgets.QMessageBox.Warning)\n    msg = \"There are outdated containers in the scene.\"\n    message_box.setText(msg)\n    message_box.exec_()\n</code></pre>"},{"location":"autoapi/client/ayon_premiere/api/pipeline.html#client.ayon_premiere.api.pipeline.containerise","title":"<code>containerise(name, namespace, bin_item, context, loader=None, imported_composition=None)</code>","text":"<p>Containerisation enables a tracking of version, author and origin for loaded assets.</p> <p>Creates dictionary payloads that gets saved into file metadata. Each container contains of who loaded (loader) and members (single or multiple in case of background).</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name of resulting assembly</p> required <code>namespace</code> <code>str</code> <p>Namespace under which to host container</p> required <code>bin_item</code> <code>PPROItem</code> <p>Bin to containerise</p> required <code>context</code> <code>dict</code> <p>Asset information</p> required <code>loader</code> <code>str</code> <p>Name of loader used to produce this container.</p> <code>None</code> <code>imported_composition</code> <code>str</code> <p>loaded composition from AE</p> <code>None</code> <p>Returns:</p> Name Type Description <code>container</code> <code>str</code> <p>Name of container assembly</p> Source code in <code>client/ayon_premiere/api/pipeline.py</code> <pre><code>def containerise(\n    name,\n    namespace,\n    bin_item,\n    context,\n    loader=None,\n    imported_composition=None\n):\n    \"\"\"\n    Containerisation enables a tracking of version, author and origin\n    for loaded assets.\n\n    Creates dictionary payloads that gets saved into file metadata. Each\n    container contains of who loaded (loader) and members (single or multiple\n    in case of background).\n\n    Arguments:\n        name (str): Name of resulting assembly\n        namespace (str): Namespace under which to host container\n        bin_item (PPROItem): Bin to containerise\n        context (dict): Asset information\n        loader (str, optional): Name of loader used to produce this container.\n        imported_composition (str, optional): loaded composition from AE\n\n    Returns:\n        container (str): Name of container assembly\n    \"\"\"\n    data = {\n        \"schema\": \"openpype:container-2.0\",\n        \"id\": AYON_CONTAINER_ID,\n        \"name\": name,\n        \"namespace\": namespace,\n        \"loader\": str(loader),\n        \"representation\": context[\"representation\"][\"id\"],\n        \"members\": [bin_item.id]\n    }\n    if imported_composition:\n        data[\"imported_composition\"] = imported_composition\n\n    stub = get_stub()\n    stub.imprint(bin_item.id, data)\n\n    return bin_item\n</code></pre>"},{"location":"autoapi/client/ayon_premiere/api/pipeline.html#client.ayon_premiere.api.pipeline.ls","title":"<code>ls()</code>","text":"<p>Yields containers from active Premiere document.</p> <p>This is the host-equivalent of api.ls(), but instead of listing assets on disk, it lists assets already loaded in AE; once loaded they are called 'containers'. Used in Manage tool.</p> <p>Containers could be on multiple levels, single images/videos/was as a FootageItem, or multiple items - backgrounds (folder with automatically created composition and all imported layers).</p> <p>Yields:</p> Name Type Description <code>dict</code> <p>container</p> Source code in <code>client/ayon_premiere/api/pipeline.py</code> <pre><code>def ls():\n    \"\"\"Yields containers from active Premiere document.\n\n    This is the host-equivalent of api.ls(), but instead of listing\n    assets on disk, it lists assets already loaded in AE; once loaded\n    they are called 'containers'. Used in Manage tool.\n\n    Containers could be on multiple levels, single images/videos/was as a\n    FootageItem, or multiple items - backgrounds (folder with automatically\n    created composition and all imported layers).\n\n    Yields:\n        dict: container\n\n    \"\"\"\n    try:\n        stub = get_stub()  # only after Premiere is up\n    except ConnectionNotEstablishedYet:\n        print(\"Not connected yet, ignoring\")\n        return\n\n    project_metadata = stub.get_metadata()\n    for item in stub.get_items(bins=True, sequences=False, footages=False):\n        metadata = stub.get_item_metadata(item, project_metadata)\n        # Skip non AYON item.\n        if not metadata:\n            continue\n\n        is_loaded_container = \"container\" not in metadata[\"id\"]\n        if is_loaded_container:\n            continue\n\n        # Append transient data\n        metadata[\"objectName\"] = item.name.replace(stub.LOADED_ICON, \"\")\n        metadata[\"bin\"] = item\n        yield metadata\n</code></pre>"},{"location":"autoapi/client/ayon_premiere/api/plugin.html","title":"plugin","text":""},{"location":"autoapi/client/ayon_premiere/api/webserver.html","title":"webserver","text":"<p>Webserver for communication with Premiere.</p> <p>Aiohttp (Asyncio) based websocket server used for communication with host application.</p> <p>This webserver is started in spawned Python process that opens DCC during its launch, waits for connection from DCC and handles communication going forward. Server is closed before Python process is killed.</p>"},{"location":"autoapi/client/ayon_premiere/api/webserver.html#client.ayon_premiere.api.webserver.WebServerThread","title":"<code>WebServerThread</code>","text":"<p>               Bases: <code>Thread</code></p> <p>Listener for websocket rpc requests.</p> <p>It would be probably better to \"attach\" this to main thread (as for example Harmony needs to run something on main thread), but currently it creates separate thread and separate asyncio event loop</p> Source code in <code>client/ayon_premiere/api/webserver.py</code> <pre><code>class WebServerThread(threading.Thread):\n    \"\"\" Listener for websocket rpc requests.\n\n        It would be probably better to \"attach\" this to main thread (as for\n        example Harmony needs to run something on main thread), but currently\n        it creates separate thread and separate asyncio event loop\n    \"\"\"\n    def __init__(self, module, port):\n        super(WebServerThread, self).__init__()\n\n        self.is_running = False\n        self.port = port\n        self.module = module\n        self.loop = None\n        self.runner = None\n        self.site = None\n        self.tasks = []\n\n    def run(self):\n        self.is_running = True\n\n        try:\n            log.info(\"Starting web server\")\n            self.loop = asyncio.new_event_loop()  # create new loop for thread\n            asyncio.set_event_loop(self.loop)\n\n            self.loop.run_until_complete(self.start_server())\n\n            websocket_url = \"ws://localhost:{}/ws\".format(self.port)\n\n            log.debug(\n                \"Running Websocket server on URL: \\\"{}\\\"\".format(websocket_url)\n            )\n\n            asyncio.ensure_future(self.check_shutdown(), loop=self.loop)\n            self.loop.run_forever()\n        except Exception:\n            self.is_running = False\n            log.warning(\n                \"Websocket Server service has failed\", exc_info=True\n            )\n            raise\n        finally:\n            self.loop.close()  # optional\n\n            self.is_running = False\n            self.module.thread_stopped()\n            log.info(\"Websocket server stopped\")\n\n    async def start_server(self):\n        \"\"\" Starts runner and TCPsite \"\"\"\n        self.runner = web.AppRunner(self.module.app)\n        await self.runner.setup()\n        self.site = web.TCPSite(self.runner, 'localhost', self.port)\n        await self.site.start()\n\n    def stop(self):\n        \"\"\"Sets is_running flag to false, 'check_shutdown' shuts server down\"\"\"\n        self.is_running = False\n\n    async def check_shutdown(self):\n        \"\"\" Future that is running and checks if server should be running\n            periodically.\n        \"\"\"\n        while self.is_running:\n            while self.tasks:\n                task = self.tasks.pop(0)\n                log.debug(\"waiting for task {}\".format(task))\n                await task\n                log.debug(\"returned value {}\".format(task.result))\n\n            await asyncio.sleep(0.5)\n\n        log.debug(\"Starting shutdown\")\n        await self.site.stop()\n        log.debug(\"Site stopped\")\n        await self.runner.cleanup()\n        log.debug(\"Runner stopped\")\n        tasks = [task for task in asyncio.all_tasks() if\n                 task is not asyncio.current_task()]\n        list(map(lambda task: task.cancel(), tasks))  # cancel all the tasks\n        results = await asyncio.gather(*tasks, return_exceptions=True)\n        log.debug(f'Finished awaiting cancelled tasks, results: {results}...')\n        await self.loop.shutdown_asyncgens()\n        # to really make sure everything else has time to stop\n        await asyncio.sleep(0.07)\n        self.loop.stop()\n</code></pre>"},{"location":"autoapi/client/ayon_premiere/api/webserver.html#client.ayon_premiere.api.webserver.WebServerThread.check_shutdown","title":"<code>check_shutdown()</code>  <code>async</code>","text":"<p>Future that is running and checks if server should be running periodically.</p> Source code in <code>client/ayon_premiere/api/webserver.py</code> <pre><code>async def check_shutdown(self):\n    \"\"\" Future that is running and checks if server should be running\n        periodically.\n    \"\"\"\n    while self.is_running:\n        while self.tasks:\n            task = self.tasks.pop(0)\n            log.debug(\"waiting for task {}\".format(task))\n            await task\n            log.debug(\"returned value {}\".format(task.result))\n\n        await asyncio.sleep(0.5)\n\n    log.debug(\"Starting shutdown\")\n    await self.site.stop()\n    log.debug(\"Site stopped\")\n    await self.runner.cleanup()\n    log.debug(\"Runner stopped\")\n    tasks = [task for task in asyncio.all_tasks() if\n             task is not asyncio.current_task()]\n    list(map(lambda task: task.cancel(), tasks))  # cancel all the tasks\n    results = await asyncio.gather(*tasks, return_exceptions=True)\n    log.debug(f'Finished awaiting cancelled tasks, results: {results}...')\n    await self.loop.shutdown_asyncgens()\n    # to really make sure everything else has time to stop\n    await asyncio.sleep(0.07)\n    self.loop.stop()\n</code></pre>"},{"location":"autoapi/client/ayon_premiere/api/webserver.html#client.ayon_premiere.api.webserver.WebServerThread.start_server","title":"<code>start_server()</code>  <code>async</code>","text":"<p>Starts runner and TCPsite</p> Source code in <code>client/ayon_premiere/api/webserver.py</code> <pre><code>async def start_server(self):\n    \"\"\" Starts runner and TCPsite \"\"\"\n    self.runner = web.AppRunner(self.module.app)\n    await self.runner.setup()\n    self.site = web.TCPSite(self.runner, 'localhost', self.port)\n    await self.site.start()\n</code></pre>"},{"location":"autoapi/client/ayon_premiere/api/webserver.html#client.ayon_premiere.api.webserver.WebServerThread.stop","title":"<code>stop()</code>","text":"<p>Sets is_running flag to false, 'check_shutdown' shuts server down</p> Source code in <code>client/ayon_premiere/api/webserver.py</code> <pre><code>def stop(self):\n    \"\"\"Sets is_running flag to false, 'check_shutdown' shuts server down\"\"\"\n    self.is_running = False\n</code></pre>"},{"location":"autoapi/client/ayon_premiere/api/webserver.html#client.ayon_premiere.api.webserver.WebServerTool","title":"<code>WebServerTool</code>","text":"<p>Basic POC implementation of asychronic websocket RPC server. Uses class in external_app_1.py to mimic implementation for single external application. 'test_client' folder contains two test implementations of client</p> Source code in <code>client/ayon_premiere/api/webserver.py</code> <pre><code>class WebServerTool:\n    \"\"\"\n        Basic POC implementation of asychronic websocket RPC server.\n        Uses class in external_app_1.py to mimic implementation for single\n        external application.\n        'test_client' folder contains two test implementations of client\n    \"\"\"\n    _instance = None\n\n    def __init__(self):\n        WebServerTool._instance = self\n\n        self.client = None\n        self.handlers = {}\n        self.on_stop_callbacks = []\n\n        port = None\n        host_name = \"localhost\"\n        websocket_url = os.getenv(\"WEBSOCKET_URL\")\n        if websocket_url:\n            parsed = urllib.parse.urlparse(websocket_url)\n            port = parsed.port\n            host_name = parsed.netloc.split(\":\")[0]\n        if not port:\n            port = 8098  # fallback\n\n        self.port = port\n        self.host_name = host_name\n\n        self.app = web.Application()\n\n        # add route with multiple methods for single \"external app\"\n        self.webserver_thread = WebServerThread(self, self.port)\n\n    def add_route(self, *args, **kwargs):\n        self.app.router.add_route(*args, **kwargs)\n\n    def add_static(self, *args, **kwargs):\n        self.app.router.add_static(*args, **kwargs)\n\n    def start_server(self):\n        if self.webserver_thread and not self.webserver_thread.is_alive():\n            self.webserver_thread.start()\n\n    def stop_server(self):\n        self.stop()\n\n    async def send_context_change(self, host):\n        \"\"\"\n            Calls running webserver to inform about context change\n\n            Used when new PS/AE should be triggered,\n            but one already running, without\n            this publish would point to old context.\n        \"\"\"\n        client = WSRPCClient(os.getenv(\"WEBSOCKET_URL\"),\n                             loop=asyncio.get_event_loop())\n        await client.connect()\n\n        context = get_global_context()\n        project_name = context[\"project_name\"]\n        folder_path = context[\"folder_path\"]\n        task_name = context[\"task_name\"]\n        log.info(\"Sending context change to {}{}/{}\".format(\n            project_name, folder_path, task_name\n        ))\n\n        await client.call(\n            '{}.set_context'.format(host),\n            project=project_name,\n            folder=folder_path,\n            task=task_name\n        )\n        await client.close()\n\n    def port_occupied(self, host_name, port):\n        \"\"\"\n            Check if 'url' is already occupied.\n\n            This could mean, that app is already running and we are trying open it\n            again. In that case, use existing running webserver.\n            Check here is easier than capturing exception from thread.\n        \"\"\"\n        with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as con:\n            result = con.connect_ex((host_name, port)) == 0\n\n        if result:\n            print(f\"Port {port} is already in use\")\n        return result\n\n    def call(self, func):\n        log.debug(\"websocket.call {}\".format(func))\n        future = asyncio.run_coroutine_threadsafe(\n            func,\n            self.webserver_thread.loop\n        )\n        result = future.result()\n        return result\n\n    @staticmethod\n    def get_instance():\n        if WebServerTool._instance is None:\n            WebServerTool()\n        return WebServerTool._instance\n\n    @property\n    def is_running(self):\n        if not self.webserver_thread:\n            return False\n        return self.webserver_thread.is_running\n\n    def stop(self):\n        if not self.is_running:\n            return\n        try:\n            log.debug(\"Stopping websocket server\")\n            self.webserver_thread.is_running = False\n            self.webserver_thread.stop()\n        except Exception:\n            log.warning(\n                \"Error has happened during Killing websocket server\",\n                exc_info=True\n            )\n\n    def thread_stopped(self):\n        for callback in self.on_stop_callbacks:\n            callback()\n</code></pre>"},{"location":"autoapi/client/ayon_premiere/api/webserver.html#client.ayon_premiere.api.webserver.WebServerTool.port_occupied","title":"<code>port_occupied(host_name, port)</code>","text":"<p>Check if 'url' is already occupied.</p> <p>This could mean, that app is already running and we are trying open it again. In that case, use existing running webserver. Check here is easier than capturing exception from thread.</p> Source code in <code>client/ayon_premiere/api/webserver.py</code> <pre><code>def port_occupied(self, host_name, port):\n    \"\"\"\n        Check if 'url' is already occupied.\n\n        This could mean, that app is already running and we are trying open it\n        again. In that case, use existing running webserver.\n        Check here is easier than capturing exception from thread.\n    \"\"\"\n    with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as con:\n        result = con.connect_ex((host_name, port)) == 0\n\n    if result:\n        print(f\"Port {port} is already in use\")\n    return result\n</code></pre>"},{"location":"autoapi/client/ayon_premiere/api/webserver.html#client.ayon_premiere.api.webserver.WebServerTool.send_context_change","title":"<code>send_context_change(host)</code>  <code>async</code>","text":"<p>Calls running webserver to inform about context change</p> <p>Used when new PS/AE should be triggered, but one already running, without this publish would point to old context.</p> Source code in <code>client/ayon_premiere/api/webserver.py</code> <pre><code>async def send_context_change(self, host):\n    \"\"\"\n        Calls running webserver to inform about context change\n\n        Used when new PS/AE should be triggered,\n        but one already running, without\n        this publish would point to old context.\n    \"\"\"\n    client = WSRPCClient(os.getenv(\"WEBSOCKET_URL\"),\n                         loop=asyncio.get_event_loop())\n    await client.connect()\n\n    context = get_global_context()\n    project_name = context[\"project_name\"]\n    folder_path = context[\"folder_path\"]\n    task_name = context[\"task_name\"]\n    log.info(\"Sending context change to {}{}/{}\".format(\n        project_name, folder_path, task_name\n    ))\n\n    await client.call(\n        '{}.set_context'.format(host),\n        project=project_name,\n        folder=folder_path,\n        task=task_name\n    )\n    await client.close()\n</code></pre>"},{"location":"autoapi/client/ayon_premiere/api/ws_stub.html","title":"ws_stub","text":"<p>Stub handling connection from server to client. Used anywhere solution is calling client methods.</p>"},{"location":"autoapi/client/ayon_premiere/api/ws_stub.html#client.ayon_premiere.api.ws_stub.PPROItem","title":"<code>PPROItem</code>  <code>dataclass</code>","text":"<p>               Bases: <code>object</code></p> <p>Object denoting Item in PPRO. Each item is created in PPRO by any Loader, but contains same fields, which are being used in later processing.</p> Source code in <code>client/ayon_premiere/api/ws_stub.py</code> <pre><code>@dataclass\nclass PPROItem(object):\n    \"\"\"\n        Object denoting Item in PPRO. Each item is created in PPRO by any\n        Loader, but contains same fields, which are being used in\n        later processing.\n    \"\"\"\n    # metadata\n    id: str = field()\n    name: str = field()\n    members: List[str] = field(default_factory=list)\n</code></pre>"},{"location":"autoapi/client/ayon_premiere/api/ws_stub.html#client.ayon_premiere.api.ws_stub.PremiereServerStub","title":"<code>PremiereServerStub</code>","text":"<p>Stub for calling function on client (Photoshop js) side. Expects that client is already connected (started when avalon menu is opened). 'self.websocketserver.call' is used as async wrapper</p> Source code in <code>client/ayon_premiere/api/ws_stub.py</code> <pre><code>class PremiereServerStub():\n    \"\"\"\n        Stub for calling function on client (Photoshop js) side.\n        Expects that client is already connected (started when avalon menu\n        is opened).\n        'self.websocketserver.call' is used as async wrapper\n    \"\"\"\n    PUBLISH_ICON = \"\\u2117 \"\n    LOADED_ICON = \"\\u25bc\"\n\n    def __init__(self):\n        self.websocketserver = WebServerTool.get_instance()\n        self.client = self.get_client()\n        self.log = logging.getLogger(self.__class__.__name__)\n\n    @staticmethod\n    def get_client():\n        \"\"\"\n            Return first connected client to WebSocket\n            TODO implement selection by Route\n        :return: &lt;WebSocketAsync&gt; client\n        \"\"\"\n        clients = WebSocketAsync.get_clients()\n        client = None\n        if len(clients) &gt; 0:\n            key = list(clients.keys())[0]\n            client = clients.get(key)\n\n        return client\n\n    def open(self, path):\n        \"\"\"\n            Open file located at 'path' (local).\n        Args:\n            path(string): file path locally\n        Returns: None\n        \"\"\"\n        res = self.websocketserver.call(self.client.call\n                                        (\"Premiere.open\", path=path))\n\n        return self._handle_return(res)\n\n    def get_metadata(self):\n        \"\"\"\n            Get complete stored JSON with metadata from dummy AYON sequence\n            field.\n\n            It contains containers loaded by any Loader OR instances created\n            by Creator.\n\n        Returns:\n            (list)\n        \"\"\"\n        res = self.websocketserver.call(self.client.call\n                                        (\"Premiere.get_metadata\"))\n        metadata = self._handle_return(res)\n\n        return metadata or []\n\n    def get_item_metadata(self, item, project_metadata=None):\n        \"\"\"\n            Parses item metadata from dummy `AYON Metadata` Bin of active\n            document.\n            Used as filter to pick metadata for specific 'item' only as\n            metadata are stored as a list in all DCCs.\n\n        Args:\n            item (PPROItem): pulled info from PPRO\n            project_metadata (dict): full stored metadata for AYON container or\n                instances\n                (load and inject for better performance in loops)\n        Returns:\n            (dict):\n        \"\"\"\n        if project_metadata is None:\n            project_metadata = self.get_metadata()\n        for item_meta in project_metadata:\n            if \"container\" in item_meta.get(\"id\") and \\\n                    item.id == item_meta.get(\"members\")[0]:\n                return item_meta\n\n        self.log.debug(\"Couldn't find item metadata\")\n\n    def imprint(self, item_id, data, all_items=None, items_meta=None):\n        \"\"\"\n            Save item metadata to Label field of metadata of active document\n        Args:\n            item_id (int|str): id of FootageItem or instance_id for workfiles\n            data(string): json representation for single layer\n            all_items (list of item): for performance, could be\n                injected for usage in loop, if not, single call will be\n                triggered\n            items_meta(string): json representation from Headline\n                           (for performance - provide only if imprint is in\n                           loop - value should be same)\n        Returns: None\n        \"\"\"\n        if not items_meta:\n            items_meta = self.get_metadata()\n\n        result_meta = []\n        # fix existing\n        is_new = True\n\n        for item_meta in items_meta:\n            if ((item_meta.get(\"members\") and\n                    str(item_id) == str(item_meta.get(\"members\")[0])) or\n                    item_meta.get(\"instance_id\") == item_id):\n                is_new = False\n                if data:\n                    item_meta.update(data)\n                    result_meta.append(item_meta)\n            else:\n                result_meta.append(item_meta)\n\n        if is_new:\n            result_meta.append(data)\n\n        # Ensure only valid ids are stored.\n        if not all_items:\n            # loaders create FootageItem now\n            all_items = self.get_items(\n                bins=True, sequences=True, footages=True)\n        item_ids = [item.id for item in all_items]\n        cleaned_data = []\n        for meta in result_meta:\n            # do not added instance with nonexistend item id\n            if meta.get(\"members\"):\n                if meta[\"members\"][0] not in item_ids:\n                    continue\n\n            cleaned_data.append(meta)\n\n        payload = json.dumps(cleaned_data, indent=4)\n\n        res = self.websocketserver.call(\n            self.client.call(\"Premiere.imprint\", payload=payload)\n        )\n        return self._handle_return(res)\n\n    def get_active_document_full_name(self):\n        \"\"\"\n            Returns absolute path of active document via ws call\n        Returns(string): file name\n        \"\"\"\n        res = self.websocketserver.call(self.client.call(\n            \"Premiere.get_active_document_full_name\"))\n\n        return self._handle_return(res)\n\n    def get_active_document_name(self):\n        \"\"\"\n            Returns just a name of active document via ws call\n        Returns(string): file name\n        \"\"\"\n        res = self.websocketserver.call(self.client.call(\n            \"Premiere.get_active_document_name\"))\n\n        return self._handle_return(res)\n\n    def get_items(self, bins, sequences=False, footages=False):\n        \"\"\"\n            Get all items from Project panel according to arguments.\n            There are multiple different types:\n                Bin - wrappers for multiple footage (image/movies)\n                Sequences - publishable set of tracks made from footages\n                Footage - imported files\n        Args:\n            bins (bool): return Bin\n            sequences (bool): return Sequences\n            footages (bool: return Footage\n\n        Returns:\n            (list) of namedtuples\n        \"\"\"\n        res = self.websocketserver.call(\n            self.client.call(\"Premiere.get_items\",\n                             bins=bins,\n                             sequences=sequences,\n                             footages=footages)\n              )\n        return self._to_records(self._handle_return(res))\n\n    def select_items(self, items):\n        \"\"\"\n            Select items in Project list\n        Args:\n            items (list): of int item ids\n        \"\"\"\n        self.websocketserver.call(\n            self.client.call(\"Premiere.select_items\", items=items))\n\n\n    def get_selected_items(self, sequences, bins=False, footages=False):\n        \"\"\"\n            Same as get_items but using selected items only\n        Args:\n            sequences (bool): return CompItems\n            bins (bool): return Bin\n            footages (bool: return FootageItem\n\n        Returns:\n            (list) of namedtuples\n\n        \"\"\"\n        res = self.websocketserver.call(self.client.call\n                                        (\"Premiere.get_selected_items\",\n                                         comps=sequences,\n                                         folders=bins,\n                                         footages=footages)\n                                        )\n        return self._to_records(self._handle_return(res))\n\n    def add_item(self, name, item_type):\n        \"\"\"\n            Adds either composition or folder to project item list.\n\n            Args:\n                name (str)\n                item_type (str): COMP|FOLDER\n        \"\"\"\n        res = self.websocketserver.call(self.client.call\n                                        (\"Premiere.add_item\",\n                                         name=name,\n                                         item_type=item_type))\n\n        return self._handle_return(res)\n\n    def get_item(self, item_id):\n        \"\"\"\n            Returns metadata for particular 'item_id' or None\n\n            Args:\n                item_id (int, or string)\n        \"\"\"\n        for item in self.get_items(bins=True, sequences=False, footages=False):\n            if str(item.id) == str(item_id):\n                return item\n\n        return None\n\n    def import_files(self, paths, item_name, is_image_sequence=False):\n        \"\"\"\n            Imports file(s) into Bin. Used in Loader\n        Args:\n            paths (list[str]): absolute path for asset files\n            item_name (string): label for created Bin\n            is_image_sequence (bool): if loaded item is image sequence\n\n        \"\"\"\n        res = self.websocketserver.call(\n            self.client.call(\n                \"Premiere.import_files\",\n                paths=paths,\n                item_name=item_name,\n                is_image_sequence=is_image_sequence\n            )\n        )\n        records = self._to_records(self._handle_return(res))\n        if records:\n            return records.pop()\n\n    def import_ae_comp(self, path, item_name, comp_names=None):\n        \"\"\"\n            Imports file(s) into Bin. Used in Loader\n        Args:\n            path (str): absolute path for AE workfile\n            item_name (string): label for created Bin\n            comp_names (list[str]): selected comp\n\n        \"\"\"\n        res = self.websocketserver.call(\n            self.client.call(\n                \"Premiere.import_ae_comp\",\n                path=path,\n                item_name=item_name,\n                comp_names=comp_names\n            )\n        )\n        records = self._to_records(self._handle_return(res))\n        if records:\n            return records.pop()\n\n    def replace_ae_comp(self, item_id, path, item_name, comp_names):\n        \"\"\"\n            Imports file(s) into Bin. Used in Loader\n        Args:\n            item_id (str): Bin id\n            path (str): absolute path for AE workfile\n            item_name (string): label for created Bin\n            comp_names (list[str]): selected comp\n\n        \"\"\"\n        res = self.websocketserver.call(\n            self.client.call(\n                \"Premiere.replace_ae_comp\",\n                item_id=item_id,\n                path=path,\n                item_name=item_name,\n                comp_names=comp_names\n            )\n        )\n        records = self._to_records(self._handle_return(res))\n        if records:\n            return records.pop()\n\n    def replace_item(self, item_id, paths, item_name, is_image_sequence):\n        \"\"\" Replace FootageItem with new file\n\n            Args:\n                item_id (int):\n                paths (string[str]):absolute path\n                item_name (string): label on item in Project list\n                is_image_sequence (bool): if should be loaded as image seq\n\n        \"\"\"\n        res = self.websocketserver.call(self.client.call(\n            \"Premiere.replace_item\",\n            item_id=item_id,\n            paths=paths,\n            item_name=item_name,\n            is_image_sequence=is_image_sequence\n        ))\n\n        records = self._to_records(self._handle_return(res))\n        if records:\n            return records.pop()\n\n    def rename_item(self, item_id, item_name):\n        \"\"\" Replace item with item_name\n\n            Args:\n                item_id (int):\n                item_name (string): label on item in Project list\n\n        \"\"\"\n        res = self.websocketserver.call(self.client.call\n                                        (\"Premiere.rename_item\",\n                                         item_id=item_id,\n                                         item_name=item_name))\n\n        return self._handle_return(res)\n\n    def delete_item(self, item_id):\n        \"\"\" Deletes *Item in a file\n            Args:\n                item_id (int):\n\n        \"\"\"\n        res = self.websocketserver.call(self.client.call\n                                        (\"Premiere.delete_item\",\n                                         item_id=item_id))\n\n        return self._handle_return(res)\n\n    def remove_instance(self, instance_id, metadata=None):\n        \"\"\"\n            Removes instance with 'instance_id' from file's metadata and\n            saves them.\n\n            Keep matching item in file though.\n\n            Args:\n                instance_id(string): instance id\n        \"\"\"\n        cleaned_data = []\n\n        if metadata is None:\n            metadata = self.get_metadata()\n\n        for instance in metadata:\n            inst_id = instance.get(\"instance_id\") or instance.get(\"uuid\")\n            if inst_id != instance_id:\n                cleaned_data.append(instance)\n\n        payload = json.dumps(cleaned_data, indent=4)\n        res = self.websocketserver.call(self.client.call\n                                        (\"Premiere.imprint\",\n                                         payload=payload))\n\n        return self._handle_return(res)\n\n    def is_saved(self):\n        # TODO\n        return True\n\n    def set_label_color(self, item_id, color_idx):\n        \"\"\"\n            Used for highlight additional information in Project panel.\n            Green color is loaded asset, blue is created asset\n        Args:\n            item_id (int):\n            color_idx (int): 0-16 Label colors from PPRO Project view\n        \"\"\"\n        res = self.websocketserver.call(self.client.call\n                                        (\"Premiere.set_label_color\",\n                                         item_id=item_id,\n                                         color_idx=color_idx))\n\n        return self._handle_return(res)\n\n    def get_comp_properties(self, comp_id):\n        \"\"\" Get composition information for render purposes\n\n            Returns startFrame, frameDuration, fps, width, height.\n\n            Args:\n                comp_id (int):\n\n            Returns:\n                (PPROItem)\n\n        \"\"\"\n        res = self.websocketserver.call(self.client.call\n                                        (\"Premiere.get_comp_properties\",\n                                         item_id=comp_id\n                                         ))\n\n        records = self._to_records(self._handle_return(res))\n        if records:\n            return records.pop()\n\n    def set_comp_properties(self, comp_id, start, duration, frame_rate,\n                            width, height):\n        \"\"\"\n            Set work area to predefined values (from Ftrack).\n            Work area directs what gets rendered.\n            Beware of rounding, PPRO expects seconds, not frames directly.\n\n        Args:\n            comp_id (int):\n            start (int): workAreaStart in frames\n            duration (int): in frames\n            frame_rate (float): frames in seconds\n            width (int): resolution width\n            height (int): resolution height\n        \"\"\"\n        res = self.websocketserver.call(self.client.call\n                                        (\"Premiere.set_comp_properties\",\n                                         item_id=comp_id,\n                                         start=start,\n                                         duration=duration,\n                                         frame_rate=frame_rate,\n                                         width=width,\n                                         height=height))\n        return self._handle_return(res)\n\n    def save(self):\n        \"\"\"\n            Saves active document\n        Returns: None\n        \"\"\"\n        res = self.websocketserver.call(self.client.call\n                                        (\"Premiere.save\"))\n\n        return self._handle_return(res)\n\n    def saveAs(self, project_path, as_copy):\n        \"\"\"\n            Saves active project to aep (copy) or png or jpg\n        Args:\n            project_path(string): full local path\n            as_copy: &lt;boolean&gt;\n        Returns: None\n        \"\"\"\n        res = self.websocketserver.call(self.client.call\n                                        (\"Premiere.saveAs\",\n                                         image_path=project_path,\n                                         as_copy=as_copy))\n\n        return self._handle_return(res)\n\n    def get_render_info(self, comp_id):\n        \"\"\" Get render queue info for render purposes\n\n            Returns:\n               (list) of (PPROItem): with 'file_name' field\n        \"\"\"\n        res = self.websocketserver.call(self.client.call\n                                        (\"Premiere.get_render_info\",\n                                         comp_id=comp_id))\n\n        records = self._to_records(self._handle_return(res))\n        return records\n\n    def get_audio_url(self, item_id):\n        \"\"\" Get audio layer absolute url for comp\n\n            Args:\n                item_id (int): composition id\n            Returns:\n                (str): absolute path url\n        \"\"\"\n        res = self.websocketserver.call(self.client.call\n                                        (\"Premiere.get_audio_url\",\n                                         item_id=item_id))\n\n        return self._handle_return(res)\n\n    def import_background(self, comp_id, comp_name, files):\n        \"\"\"\n            Imports backgrounds images to existing or new composition.\n\n            If comp_id is not provided, new composition is created, basic\n            values (width, heights, frameRatio) takes from first imported\n            image.\n\n            All images from background json are imported as a FootageItem and\n            separate layer is created for each of them under composition.\n\n            Order of imported 'files' is important.\n\n            Args:\n                comp_id (int): id of existing composition (null if new)\n                comp_name (str): used when new composition\n                files (list): list of absolute paths to import and\n                add as layers\n\n            Returns:\n                (PPROItem): object with id of created folder, all imported images\n        \"\"\"\n        res = self.websocketserver.call(self.client.call\n                                        (\"Premiere.import_background\",\n                                         comp_id=comp_id,\n                                         comp_name=comp_name,\n                                         files=files))\n\n        records = self._to_records(self._handle_return(res))\n        if records:\n            return records.pop()\n\n    def reload_background(self, comp_id, comp_name, files):\n        \"\"\"\n            Reloads backgrounds images to existing composition.\n\n            It actually deletes complete folder with imported images and\n            created composition for safety.\n\n            Args:\n                comp_id (int): id of existing composition to be overwritten\n                comp_name (str): new name of composition (could be same as old\n                    if version up only)\n                files (list): list of absolute paths to import and\n                    add as layers\n            Returns:\n                (PPROItem): object with id of created folder, all imported images\n        \"\"\"\n        res = self.websocketserver.call(self.client.call\n                                        (\"Premiere.reload_background\",\n                                         comp_id=comp_id,\n                                         comp_name=comp_name,\n                                         files=files))\n\n        records = self._to_records(self._handle_return(res))\n        if records:\n            return records.pop()\n\n    def add_item_as_layer(self, comp_id, item_id):\n        \"\"\"\n            Adds already imported FootageItem ('item_id') as a new\n            layer to composition ('comp_id').\n\n            Args:\n                comp_id (int): id of target composition\n                item_id (int): FootageItem.id\n                comp already found previously\n        \"\"\"\n        res = self.websocketserver.call(self.client.call\n                                        (\"Premiere.add_item_as_layer\",\n                                         comp_id=comp_id,\n                                         item_id=item_id))\n\n        records = self._to_records(self._handle_return(res))\n        if records:\n            return records.pop()\n\n    def add_item_instead_placeholder(self, placeholder_item_id, item_id):\n        \"\"\"\n            Adds item_id to layers where plaeholder_item_id is present.\n\n            1 placeholder could result in multiple loaded containers (eg items)\n\n            Args:\n                placeholder_item_id (int): id of placeholder item\n                item_id (int): loaded FootageItem id\n        \"\"\"\n        res = self.websocketserver.call(self.client.call\n                                        (\"Premiere.add_item_instead_placeholder\",  # noqa\n                                         placeholder_item_id=placeholder_item_id,  # noqa\n                                         item_id=item_id))\n\n        return self._handle_return(res)\n\n    def add_placeholder(self, name, width, height, fps, duration):\n        \"\"\"\n            Adds new FootageItem as a placeholder for workfile builder\n\n            Placeholder requires width etc, currently probably only hardcoded\n            values.\n\n            Args:\n                name (str)\n                width (int)\n                height (int)\n                fps (float)\n                duration (int)\n        \"\"\"\n        res = self.websocketserver.call(self.client.call\n                                        (\"Premiere.add_placeholder\",\n                                         name=name,\n                                         width=width,\n                                         height=height,\n                                         fps=fps,\n                                         duration=duration))\n\n        return self._handle_return(res)\n\n    def render(self, folder_url, comp_id):\n        \"\"\"\n            Render all renderqueueitem to 'folder_url'\n        Args:\n            folder_url(string): local folder path for collecting\n        Returns: None\n        \"\"\"\n        res = self.websocketserver.call(self.client.call\n                                        (\"Premiere.render\",\n                                         folder_url=folder_url,\n                                         comp_id=comp_id))\n        return self._handle_return(res)\n\n    def get_extension_version(self):\n        \"\"\"Returns version number of installed extension.\"\"\"\n        res = self.websocketserver.call(self.client.call(\n            \"Premiere.get_extension_version\"))\n\n        return self._handle_return(res)\n\n    def get_app_version(self):\n        \"\"\"Returns version number of installed application (17.5...).\"\"\"\n        res = self.websocketserver.call(self.client.call(\n            \"Premiere.get_app_version\"))\n\n        return self._handle_return(res)\n\n    def close(self):\n        res = self.websocketserver.call(self.client.call(\"Premiere.close\"))\n\n        return self._handle_return(res)\n\n    def print_msg(self, msg):\n        \"\"\"Triggers Javascript alert dialog.\"\"\"\n        self.websocketserver.call(self.client.call\n                                  (\"Premiere.print_msg\",\n                                   msg=msg))\n\n    def _handle_return(self, res):\n        \"\"\"Wraps return, throws ValueError if 'error' key is present.\"\"\"\n        if res and isinstance(res, str) and res != \"undefined\":\n            try:\n                parsed = json.loads(res)\n            except json.decoder.JSONDecodeError:\n                raise ValueError(\"Received broken JSON '{}'\".format(res))\n\n            if not parsed:  # empty list\n                return parsed\n\n            first_item = parsed\n            if isinstance(parsed, list):\n                first_item = parsed[0]\n\n            if first_item:\n                if first_item.get(\"error\"):\n                    raise ValueError(first_item[\"error\"])\n                # singular values (file name etc)\n                if first_item.get(\"result\") is not None:\n                    return first_item[\"result\"]\n            return parsed  # parsed\n        return res\n\n    def _to_records(self, payload):\n        \"\"\"\n            Converts string json representation into list of PPROItem\n            dot notation access to work.\n        Returns: &lt;list of PPROItem&gt;\n            payload(dict): - dictionary from json representation, expected to\n                come from _handle_return\n        \"\"\"\n        if not payload:\n            return []\n\n        if isinstance(payload, str):  # safety fallback\n            try:\n                payload = json.loads(payload)\n            except json.decoder.JSONDecodeError:\n                raise ValueError(\"Received broken JSON {}\".format(payload))\n\n        if isinstance(payload, dict):\n            payload = [payload]\n\n        ret = []\n        # convert to PPROItem to use dot donation\n        for d in payload:\n            if not d:\n                continue\n            # currently implemented and expected fields\n            item = PPROItem(\n                d.get(\"id\"),\n                d.get(\"name\"),\n                # d.get(\"type\"),\n                d.get(\"members\"),\n                # d.get(\"frameStart\"),\n                # d.get(\"framesDuration\"),\n                # d.get(\"frameRate\"),\n                # d.get(\"file_name\"),\n                # d.get(\"instance_id\"),\n                # d.get(\"width\"),\n                # d.get(\"height\"),\n                # d.get(\"is_placeholder\"),\n                # d.get(\"uuid\"),\n                # d.get(\"path\"),\n                # d.get(\"containing_comps\"),\n            )\n\n            ret.append(item)\n        return ret\n</code></pre>"},{"location":"autoapi/client/ayon_premiere/api/ws_stub.html#client.ayon_premiere.api.ws_stub.PremiereServerStub.add_item","title":"<code>add_item(name, item_type)</code>","text":"<p>Adds either composition or folder to project item list.</p> <p>Parameters:</p> Name Type Description Default <code>item_type</code> <code>str</code> <p>COMP|FOLDER</p> required Source code in <code>client/ayon_premiere/api/ws_stub.py</code> <pre><code>def add_item(self, name, item_type):\n    \"\"\"\n        Adds either composition or folder to project item list.\n\n        Args:\n            name (str)\n            item_type (str): COMP|FOLDER\n    \"\"\"\n    res = self.websocketserver.call(self.client.call\n                                    (\"Premiere.add_item\",\n                                     name=name,\n                                     item_type=item_type))\n\n    return self._handle_return(res)\n</code></pre>"},{"location":"autoapi/client/ayon_premiere/api/ws_stub.html#client.ayon_premiere.api.ws_stub.PremiereServerStub.add_item_as_layer","title":"<code>add_item_as_layer(comp_id, item_id)</code>","text":"<p>Adds already imported FootageItem ('item_id') as a new layer to composition ('comp_id').</p> <p>Parameters:</p> Name Type Description Default <code>comp_id</code> <code>int</code> <p>id of target composition</p> required <code>item_id</code> <code>int</code> <p>FootageItem.id</p> required Source code in <code>client/ayon_premiere/api/ws_stub.py</code> <pre><code>def add_item_as_layer(self, comp_id, item_id):\n    \"\"\"\n        Adds already imported FootageItem ('item_id') as a new\n        layer to composition ('comp_id').\n\n        Args:\n            comp_id (int): id of target composition\n            item_id (int): FootageItem.id\n            comp already found previously\n    \"\"\"\n    res = self.websocketserver.call(self.client.call\n                                    (\"Premiere.add_item_as_layer\",\n                                     comp_id=comp_id,\n                                     item_id=item_id))\n\n    records = self._to_records(self._handle_return(res))\n    if records:\n        return records.pop()\n</code></pre>"},{"location":"autoapi/client/ayon_premiere/api/ws_stub.html#client.ayon_premiere.api.ws_stub.PremiereServerStub.add_item_instead_placeholder","title":"<code>add_item_instead_placeholder(placeholder_item_id, item_id)</code>","text":"<p>Adds item_id to layers where plaeholder_item_id is present.</p> <p>1 placeholder could result in multiple loaded containers (eg items)</p> <p>Parameters:</p> Name Type Description Default <code>placeholder_item_id</code> <code>int</code> <p>id of placeholder item</p> required <code>item_id</code> <code>int</code> <p>loaded FootageItem id</p> required Source code in <code>client/ayon_premiere/api/ws_stub.py</code> <pre><code>def add_item_instead_placeholder(self, placeholder_item_id, item_id):\n    \"\"\"\n        Adds item_id to layers where plaeholder_item_id is present.\n\n        1 placeholder could result in multiple loaded containers (eg items)\n\n        Args:\n            placeholder_item_id (int): id of placeholder item\n            item_id (int): loaded FootageItem id\n    \"\"\"\n    res = self.websocketserver.call(self.client.call\n                                    (\"Premiere.add_item_instead_placeholder\",  # noqa\n                                     placeholder_item_id=placeholder_item_id,  # noqa\n                                     item_id=item_id))\n\n    return self._handle_return(res)\n</code></pre>"},{"location":"autoapi/client/ayon_premiere/api/ws_stub.html#client.ayon_premiere.api.ws_stub.PremiereServerStub.add_placeholder","title":"<code>add_placeholder(name, width, height, fps, duration)</code>","text":"<p>Adds new FootageItem as a placeholder for workfile builder</p> <p>Placeholder requires width etc, currently probably only hardcoded values.</p> Source code in <code>client/ayon_premiere/api/ws_stub.py</code> <pre><code>def add_placeholder(self, name, width, height, fps, duration):\n    \"\"\"\n        Adds new FootageItem as a placeholder for workfile builder\n\n        Placeholder requires width etc, currently probably only hardcoded\n        values.\n\n        Args:\n            name (str)\n            width (int)\n            height (int)\n            fps (float)\n            duration (int)\n    \"\"\"\n    res = self.websocketserver.call(self.client.call\n                                    (\"Premiere.add_placeholder\",\n                                     name=name,\n                                     width=width,\n                                     height=height,\n                                     fps=fps,\n                                     duration=duration))\n\n    return self._handle_return(res)\n</code></pre>"},{"location":"autoapi/client/ayon_premiere/api/ws_stub.html#client.ayon_premiere.api.ws_stub.PremiereServerStub.delete_item","title":"<code>delete_item(item_id)</code>","text":"<p>Deletes *Item in a file Args:     item_id (int):</p> Source code in <code>client/ayon_premiere/api/ws_stub.py</code> <pre><code>def delete_item(self, item_id):\n    \"\"\" Deletes *Item in a file\n        Args:\n            item_id (int):\n\n    \"\"\"\n    res = self.websocketserver.call(self.client.call\n                                    (\"Premiere.delete_item\",\n                                     item_id=item_id))\n\n    return self._handle_return(res)\n</code></pre>"},{"location":"autoapi/client/ayon_premiere/api/ws_stub.html#client.ayon_premiere.api.ws_stub.PremiereServerStub.get_active_document_full_name","title":"<code>get_active_document_full_name()</code>","text":"<pre><code>Returns absolute path of active document via ws call\n</code></pre> <p>Returns(string): file name</p> Source code in <code>client/ayon_premiere/api/ws_stub.py</code> <pre><code>def get_active_document_full_name(self):\n    \"\"\"\n        Returns absolute path of active document via ws call\n    Returns(string): file name\n    \"\"\"\n    res = self.websocketserver.call(self.client.call(\n        \"Premiere.get_active_document_full_name\"))\n\n    return self._handle_return(res)\n</code></pre>"},{"location":"autoapi/client/ayon_premiere/api/ws_stub.html#client.ayon_premiere.api.ws_stub.PremiereServerStub.get_active_document_name","title":"<code>get_active_document_name()</code>","text":"<pre><code>Returns just a name of active document via ws call\n</code></pre> <p>Returns(string): file name</p> Source code in <code>client/ayon_premiere/api/ws_stub.py</code> <pre><code>def get_active_document_name(self):\n    \"\"\"\n        Returns just a name of active document via ws call\n    Returns(string): file name\n    \"\"\"\n    res = self.websocketserver.call(self.client.call(\n        \"Premiere.get_active_document_name\"))\n\n    return self._handle_return(res)\n</code></pre>"},{"location":"autoapi/client/ayon_premiere/api/ws_stub.html#client.ayon_premiere.api.ws_stub.PremiereServerStub.get_app_version","title":"<code>get_app_version()</code>","text":"<p>Returns version number of installed application (17.5...).</p> Source code in <code>client/ayon_premiere/api/ws_stub.py</code> <pre><code>def get_app_version(self):\n    \"\"\"Returns version number of installed application (17.5...).\"\"\"\n    res = self.websocketserver.call(self.client.call(\n        \"Premiere.get_app_version\"))\n\n    return self._handle_return(res)\n</code></pre>"},{"location":"autoapi/client/ayon_premiere/api/ws_stub.html#client.ayon_premiere.api.ws_stub.PremiereServerStub.get_audio_url","title":"<code>get_audio_url(item_id)</code>","text":"<p>Get audio layer absolute url for comp</p> <p>Parameters:</p> Name Type Description Default <code>item_id</code> <code>int</code> <p>composition id</p> required <p>Returns:     (str): absolute path url</p> Source code in <code>client/ayon_premiere/api/ws_stub.py</code> <pre><code>def get_audio_url(self, item_id):\n    \"\"\" Get audio layer absolute url for comp\n\n        Args:\n            item_id (int): composition id\n        Returns:\n            (str): absolute path url\n    \"\"\"\n    res = self.websocketserver.call(self.client.call\n                                    (\"Premiere.get_audio_url\",\n                                     item_id=item_id))\n\n    return self._handle_return(res)\n</code></pre>"},{"location":"autoapi/client/ayon_premiere/api/ws_stub.html#client.ayon_premiere.api.ws_stub.PremiereServerStub.get_client","title":"<code>get_client()</code>  <code>staticmethod</code>","text":"<pre><code>Return first connected client to WebSocket\nTODO implement selection by Route\n</code></pre> <p>:return:  client Source code in <code>client/ayon_premiere/api/ws_stub.py</code> <pre><code>@staticmethod\ndef get_client():\n    \"\"\"\n        Return first connected client to WebSocket\n        TODO implement selection by Route\n    :return: &lt;WebSocketAsync&gt; client\n    \"\"\"\n    clients = WebSocketAsync.get_clients()\n    client = None\n    if len(clients) &gt; 0:\n        key = list(clients.keys())[0]\n        client = clients.get(key)\n\n    return client\n</code></pre>"},{"location":"autoapi/client/ayon_premiere/api/ws_stub.html#client.ayon_premiere.api.ws_stub.PremiereServerStub.get_comp_properties","title":"<code>get_comp_properties(comp_id)</code>","text":"<p>Get composition information for render purposes</p> <p>Returns startFrame, frameDuration, fps, width, height.</p> <p>Parameters:</p> Name Type Description Default <code>comp_id</code> <code>int</code> required <p>Returns:</p> Type Description <p>(PPROItem)</p> Source code in <code>client/ayon_premiere/api/ws_stub.py</code> <pre><code>def get_comp_properties(self, comp_id):\n    \"\"\" Get composition information for render purposes\n\n        Returns startFrame, frameDuration, fps, width, height.\n\n        Args:\n            comp_id (int):\n\n        Returns:\n            (PPROItem)\n\n    \"\"\"\n    res = self.websocketserver.call(self.client.call\n                                    (\"Premiere.get_comp_properties\",\n                                     item_id=comp_id\n                                     ))\n\n    records = self._to_records(self._handle_return(res))\n    if records:\n        return records.pop()\n</code></pre>"},{"location":"autoapi/client/ayon_premiere/api/ws_stub.html#client.ayon_premiere.api.ws_stub.PremiereServerStub.get_extension_version","title":"<code>get_extension_version()</code>","text":"<p>Returns version number of installed extension.</p> Source code in <code>client/ayon_premiere/api/ws_stub.py</code> <pre><code>def get_extension_version(self):\n    \"\"\"Returns version number of installed extension.\"\"\"\n    res = self.websocketserver.call(self.client.call(\n        \"Premiere.get_extension_version\"))\n\n    return self._handle_return(res)\n</code></pre>"},{"location":"autoapi/client/ayon_premiere/api/ws_stub.html#client.ayon_premiere.api.ws_stub.PremiereServerStub.get_item","title":"<code>get_item(item_id)</code>","text":"<p>Returns metadata for particular 'item_id' or None</p> Source code in <code>client/ayon_premiere/api/ws_stub.py</code> <pre><code>def get_item(self, item_id):\n    \"\"\"\n        Returns metadata for particular 'item_id' or None\n\n        Args:\n            item_id (int, or string)\n    \"\"\"\n    for item in self.get_items(bins=True, sequences=False, footages=False):\n        if str(item.id) == str(item_id):\n            return item\n\n    return None\n</code></pre>"},{"location":"autoapi/client/ayon_premiere/api/ws_stub.html#client.ayon_premiere.api.ws_stub.PremiereServerStub.get_item_metadata","title":"<code>get_item_metadata(item, project_metadata=None)</code>","text":"<pre><code>Parses item metadata from dummy `AYON Metadata` Bin of active\ndocument.\nUsed as filter to pick metadata for specific 'item' only as\nmetadata are stored as a list in all DCCs.\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>PPROItem</code> <p>pulled info from PPRO</p> required <code>project_metadata</code> <code>dict</code> <p>full stored metadata for AYON container or instances (load and inject for better performance in loops)</p> <code>None</code> <p>Returns:     (dict):</p> Source code in <code>client/ayon_premiere/api/ws_stub.py</code> <pre><code>def get_item_metadata(self, item, project_metadata=None):\n    \"\"\"\n        Parses item metadata from dummy `AYON Metadata` Bin of active\n        document.\n        Used as filter to pick metadata for specific 'item' only as\n        metadata are stored as a list in all DCCs.\n\n    Args:\n        item (PPROItem): pulled info from PPRO\n        project_metadata (dict): full stored metadata for AYON container or\n            instances\n            (load and inject for better performance in loops)\n    Returns:\n        (dict):\n    \"\"\"\n    if project_metadata is None:\n        project_metadata = self.get_metadata()\n    for item_meta in project_metadata:\n        if \"container\" in item_meta.get(\"id\") and \\\n                item.id == item_meta.get(\"members\")[0]:\n            return item_meta\n\n    self.log.debug(\"Couldn't find item metadata\")\n</code></pre>"},{"location":"autoapi/client/ayon_premiere/api/ws_stub.html#client.ayon_premiere.api.ws_stub.PremiereServerStub.get_items","title":"<code>get_items(bins, sequences=False, footages=False)</code>","text":"<pre><code>Get all items from Project panel according to arguments.\nThere are multiple different types:\n    Bin - wrappers for multiple footage (image/movies)\n    Sequences - publishable set of tracks made from footages\n    Footage - imported files\n</code></pre> <p>Args:     bins (bool): return Bin     sequences (bool): return Sequences     footages (bool: return Footage</p> <p>Returns:</p> Type Description <p>(list) of namedtuples</p> Source code in <code>client/ayon_premiere/api/ws_stub.py</code> <pre><code>def get_items(self, bins, sequences=False, footages=False):\n    \"\"\"\n        Get all items from Project panel according to arguments.\n        There are multiple different types:\n            Bin - wrappers for multiple footage (image/movies)\n            Sequences - publishable set of tracks made from footages\n            Footage - imported files\n    Args:\n        bins (bool): return Bin\n        sequences (bool): return Sequences\n        footages (bool: return Footage\n\n    Returns:\n        (list) of namedtuples\n    \"\"\"\n    res = self.websocketserver.call(\n        self.client.call(\"Premiere.get_items\",\n                         bins=bins,\n                         sequences=sequences,\n                         footages=footages)\n          )\n    return self._to_records(self._handle_return(res))\n</code></pre>"},{"location":"autoapi/client/ayon_premiere/api/ws_stub.html#client.ayon_premiere.api.ws_stub.PremiereServerStub.get_metadata","title":"<code>get_metadata()</code>","text":"<pre><code>Get complete stored JSON with metadata from dummy AYON sequence\nfield.\n\nIt contains containers loaded by any Loader OR instances created\nby Creator.\n</code></pre> <p>Returns:</p> Type Description <p>(list)</p> Source code in <code>client/ayon_premiere/api/ws_stub.py</code> <pre><code>def get_metadata(self):\n    \"\"\"\n        Get complete stored JSON with metadata from dummy AYON sequence\n        field.\n\n        It contains containers loaded by any Loader OR instances created\n        by Creator.\n\n    Returns:\n        (list)\n    \"\"\"\n    res = self.websocketserver.call(self.client.call\n                                    (\"Premiere.get_metadata\"))\n    metadata = self._handle_return(res)\n\n    return metadata or []\n</code></pre>"},{"location":"autoapi/client/ayon_premiere/api/ws_stub.html#client.ayon_premiere.api.ws_stub.PremiereServerStub.get_render_info","title":"<code>get_render_info(comp_id)</code>","text":"<p>Get render queue info for render purposes</p> <p>Returns:</p> Type Description <code>list) of (PPROItem</code> <p>with 'file_name' field</p> Source code in <code>client/ayon_premiere/api/ws_stub.py</code> <pre><code>def get_render_info(self, comp_id):\n    \"\"\" Get render queue info for render purposes\n\n        Returns:\n           (list) of (PPROItem): with 'file_name' field\n    \"\"\"\n    res = self.websocketserver.call(self.client.call\n                                    (\"Premiere.get_render_info\",\n                                     comp_id=comp_id))\n\n    records = self._to_records(self._handle_return(res))\n    return records\n</code></pre>"},{"location":"autoapi/client/ayon_premiere/api/ws_stub.html#client.ayon_premiere.api.ws_stub.PremiereServerStub.get_selected_items","title":"<code>get_selected_items(sequences, bins=False, footages=False)</code>","text":"<pre><code>Same as get_items but using selected items only\n</code></pre> <p>Args:     sequences (bool): return CompItems     bins (bool): return Bin     footages (bool: return FootageItem</p> <p>Returns:</p> Type Description <p>(list) of namedtuples</p> Source code in <code>client/ayon_premiere/api/ws_stub.py</code> <pre><code>def get_selected_items(self, sequences, bins=False, footages=False):\n    \"\"\"\n        Same as get_items but using selected items only\n    Args:\n        sequences (bool): return CompItems\n        bins (bool): return Bin\n        footages (bool: return FootageItem\n\n    Returns:\n        (list) of namedtuples\n\n    \"\"\"\n    res = self.websocketserver.call(self.client.call\n                                    (\"Premiere.get_selected_items\",\n                                     comps=sequences,\n                                     folders=bins,\n                                     footages=footages)\n                                    )\n    return self._to_records(self._handle_return(res))\n</code></pre>"},{"location":"autoapi/client/ayon_premiere/api/ws_stub.html#client.ayon_premiere.api.ws_stub.PremiereServerStub.import_ae_comp","title":"<code>import_ae_comp(path, item_name, comp_names=None)</code>","text":"<pre><code>Imports file(s) into Bin. Used in Loader\n</code></pre> <p>Args:     path (str): absolute path for AE workfile     item_name (string): label for created Bin     comp_names (list[str]): selected comp</p> Source code in <code>client/ayon_premiere/api/ws_stub.py</code> <pre><code>def import_ae_comp(self, path, item_name, comp_names=None):\n    \"\"\"\n        Imports file(s) into Bin. Used in Loader\n    Args:\n        path (str): absolute path for AE workfile\n        item_name (string): label for created Bin\n        comp_names (list[str]): selected comp\n\n    \"\"\"\n    res = self.websocketserver.call(\n        self.client.call(\n            \"Premiere.import_ae_comp\",\n            path=path,\n            item_name=item_name,\n            comp_names=comp_names\n        )\n    )\n    records = self._to_records(self._handle_return(res))\n    if records:\n        return records.pop()\n</code></pre>"},{"location":"autoapi/client/ayon_premiere/api/ws_stub.html#client.ayon_premiere.api.ws_stub.PremiereServerStub.import_background","title":"<code>import_background(comp_id, comp_name, files)</code>","text":"<p>Imports backgrounds images to existing or new composition.</p> <p>If comp_id is not provided, new composition is created, basic values (width, heights, frameRatio) takes from first imported image.</p> <p>All images from background json are imported as a FootageItem and separate layer is created for each of them under composition.</p> <p>Order of imported 'files' is important.</p> <p>Parameters:</p> Name Type Description Default <code>comp_id</code> <code>int</code> <p>id of existing composition (null if new)</p> required <code>comp_name</code> <code>str</code> <p>used when new composition</p> required <code>files</code> <code>list</code> <p>list of absolute paths to import and</p> required <p>Returns:</p> Type Description <code>PPROItem</code> <p>object with id of created folder, all imported images</p> Source code in <code>client/ayon_premiere/api/ws_stub.py</code> <pre><code>def import_background(self, comp_id, comp_name, files):\n    \"\"\"\n        Imports backgrounds images to existing or new composition.\n\n        If comp_id is not provided, new composition is created, basic\n        values (width, heights, frameRatio) takes from first imported\n        image.\n\n        All images from background json are imported as a FootageItem and\n        separate layer is created for each of them under composition.\n\n        Order of imported 'files' is important.\n\n        Args:\n            comp_id (int): id of existing composition (null if new)\n            comp_name (str): used when new composition\n            files (list): list of absolute paths to import and\n            add as layers\n\n        Returns:\n            (PPROItem): object with id of created folder, all imported images\n    \"\"\"\n    res = self.websocketserver.call(self.client.call\n                                    (\"Premiere.import_background\",\n                                     comp_id=comp_id,\n                                     comp_name=comp_name,\n                                     files=files))\n\n    records = self._to_records(self._handle_return(res))\n    if records:\n        return records.pop()\n</code></pre>"},{"location":"autoapi/client/ayon_premiere/api/ws_stub.html#client.ayon_premiere.api.ws_stub.PremiereServerStub.import_files","title":"<code>import_files(paths, item_name, is_image_sequence=False)</code>","text":"<pre><code>Imports file(s) into Bin. Used in Loader\n</code></pre> <p>Args:     paths (list[str]): absolute path for asset files     item_name (string): label for created Bin     is_image_sequence (bool): if loaded item is image sequence</p> Source code in <code>client/ayon_premiere/api/ws_stub.py</code> <pre><code>def import_files(self, paths, item_name, is_image_sequence=False):\n    \"\"\"\n        Imports file(s) into Bin. Used in Loader\n    Args:\n        paths (list[str]): absolute path for asset files\n        item_name (string): label for created Bin\n        is_image_sequence (bool): if loaded item is image sequence\n\n    \"\"\"\n    res = self.websocketserver.call(\n        self.client.call(\n            \"Premiere.import_files\",\n            paths=paths,\n            item_name=item_name,\n            is_image_sequence=is_image_sequence\n        )\n    )\n    records = self._to_records(self._handle_return(res))\n    if records:\n        return records.pop()\n</code></pre>"},{"location":"autoapi/client/ayon_premiere/api/ws_stub.html#client.ayon_premiere.api.ws_stub.PremiereServerStub.imprint","title":"<code>imprint(item_id, data, all_items=None, items_meta=None)</code>","text":"<pre><code>Save item metadata to Label field of metadata of active document\n</code></pre> <p>Args:     item_id (int|str): id of FootageItem or instance_id for workfiles     data(string): json representation for single layer     all_items (list of item): for performance, could be         injected for usage in loop, if not, single call will be         triggered     items_meta(string): json representation from Headline                    (for performance - provide only if imprint is in                    loop - value should be same) Returns: None</p> Source code in <code>client/ayon_premiere/api/ws_stub.py</code> <pre><code>def imprint(self, item_id, data, all_items=None, items_meta=None):\n    \"\"\"\n        Save item metadata to Label field of metadata of active document\n    Args:\n        item_id (int|str): id of FootageItem or instance_id for workfiles\n        data(string): json representation for single layer\n        all_items (list of item): for performance, could be\n            injected for usage in loop, if not, single call will be\n            triggered\n        items_meta(string): json representation from Headline\n                       (for performance - provide only if imprint is in\n                       loop - value should be same)\n    Returns: None\n    \"\"\"\n    if not items_meta:\n        items_meta = self.get_metadata()\n\n    result_meta = []\n    # fix existing\n    is_new = True\n\n    for item_meta in items_meta:\n        if ((item_meta.get(\"members\") and\n                str(item_id) == str(item_meta.get(\"members\")[0])) or\n                item_meta.get(\"instance_id\") == item_id):\n            is_new = False\n            if data:\n                item_meta.update(data)\n                result_meta.append(item_meta)\n        else:\n            result_meta.append(item_meta)\n\n    if is_new:\n        result_meta.append(data)\n\n    # Ensure only valid ids are stored.\n    if not all_items:\n        # loaders create FootageItem now\n        all_items = self.get_items(\n            bins=True, sequences=True, footages=True)\n    item_ids = [item.id for item in all_items]\n    cleaned_data = []\n    for meta in result_meta:\n        # do not added instance with nonexistend item id\n        if meta.get(\"members\"):\n            if meta[\"members\"][0] not in item_ids:\n                continue\n\n        cleaned_data.append(meta)\n\n    payload = json.dumps(cleaned_data, indent=4)\n\n    res = self.websocketserver.call(\n        self.client.call(\"Premiere.imprint\", payload=payload)\n    )\n    return self._handle_return(res)\n</code></pre>"},{"location":"autoapi/client/ayon_premiere/api/ws_stub.html#client.ayon_premiere.api.ws_stub.PremiereServerStub.open","title":"<code>open(path)</code>","text":"<pre><code>Open file located at 'path' (local).\n</code></pre> <p>Args:     path(string): file path locally Returns: None</p> Source code in <code>client/ayon_premiere/api/ws_stub.py</code> <pre><code>def open(self, path):\n    \"\"\"\n        Open file located at 'path' (local).\n    Args:\n        path(string): file path locally\n    Returns: None\n    \"\"\"\n    res = self.websocketserver.call(self.client.call\n                                    (\"Premiere.open\", path=path))\n\n    return self._handle_return(res)\n</code></pre>"},{"location":"autoapi/client/ayon_premiere/api/ws_stub.html#client.ayon_premiere.api.ws_stub.PremiereServerStub.print_msg","title":"<code>print_msg(msg)</code>","text":"<p>Triggers Javascript alert dialog.</p> Source code in <code>client/ayon_premiere/api/ws_stub.py</code> <pre><code>def print_msg(self, msg):\n    \"\"\"Triggers Javascript alert dialog.\"\"\"\n    self.websocketserver.call(self.client.call\n                              (\"Premiere.print_msg\",\n                               msg=msg))\n</code></pre>"},{"location":"autoapi/client/ayon_premiere/api/ws_stub.html#client.ayon_premiere.api.ws_stub.PremiereServerStub.reload_background","title":"<code>reload_background(comp_id, comp_name, files)</code>","text":"<p>Reloads backgrounds images to existing composition.</p> <p>It actually deletes complete folder with imported images and created composition for safety.</p> <p>Parameters:</p> Name Type Description Default <code>comp_id</code> <code>int</code> <p>id of existing composition to be overwritten</p> required <code>comp_name</code> <code>str</code> <p>new name of composition (could be same as old if version up only)</p> required <code>files</code> <code>list</code> <p>list of absolute paths to import and add as layers</p> required <p>Returns:     (PPROItem): object with id of created folder, all imported images</p> Source code in <code>client/ayon_premiere/api/ws_stub.py</code> <pre><code>def reload_background(self, comp_id, comp_name, files):\n    \"\"\"\n        Reloads backgrounds images to existing composition.\n\n        It actually deletes complete folder with imported images and\n        created composition for safety.\n\n        Args:\n            comp_id (int): id of existing composition to be overwritten\n            comp_name (str): new name of composition (could be same as old\n                if version up only)\n            files (list): list of absolute paths to import and\n                add as layers\n        Returns:\n            (PPROItem): object with id of created folder, all imported images\n    \"\"\"\n    res = self.websocketserver.call(self.client.call\n                                    (\"Premiere.reload_background\",\n                                     comp_id=comp_id,\n                                     comp_name=comp_name,\n                                     files=files))\n\n    records = self._to_records(self._handle_return(res))\n    if records:\n        return records.pop()\n</code></pre>"},{"location":"autoapi/client/ayon_premiere/api/ws_stub.html#client.ayon_premiere.api.ws_stub.PremiereServerStub.remove_instance","title":"<code>remove_instance(instance_id, metadata=None)</code>","text":"<p>Removes instance with 'instance_id' from file's metadata and saves them.</p> <p>Keep matching item in file though.</p> <p>Parameters:</p> Name Type Description Default <code>instance_id</code> <code>string</code> <p>instance id</p> required Source code in <code>client/ayon_premiere/api/ws_stub.py</code> <pre><code>def remove_instance(self, instance_id, metadata=None):\n    \"\"\"\n        Removes instance with 'instance_id' from file's metadata and\n        saves them.\n\n        Keep matching item in file though.\n\n        Args:\n            instance_id(string): instance id\n    \"\"\"\n    cleaned_data = []\n\n    if metadata is None:\n        metadata = self.get_metadata()\n\n    for instance in metadata:\n        inst_id = instance.get(\"instance_id\") or instance.get(\"uuid\")\n        if inst_id != instance_id:\n            cleaned_data.append(instance)\n\n    payload = json.dumps(cleaned_data, indent=4)\n    res = self.websocketserver.call(self.client.call\n                                    (\"Premiere.imprint\",\n                                     payload=payload))\n\n    return self._handle_return(res)\n</code></pre>"},{"location":"autoapi/client/ayon_premiere/api/ws_stub.html#client.ayon_premiere.api.ws_stub.PremiereServerStub.rename_item","title":"<code>rename_item(item_id, item_name)</code>","text":"<p>Replace item with item_name</p> <p>Parameters:</p> Name Type Description Default <code>item_id</code> <code>int</code> required <code>item_name</code> <code>string</code> <p>label on item in Project list</p> required Source code in <code>client/ayon_premiere/api/ws_stub.py</code> <pre><code>def rename_item(self, item_id, item_name):\n    \"\"\" Replace item with item_name\n\n        Args:\n            item_id (int):\n            item_name (string): label on item in Project list\n\n    \"\"\"\n    res = self.websocketserver.call(self.client.call\n                                    (\"Premiere.rename_item\",\n                                     item_id=item_id,\n                                     item_name=item_name))\n\n    return self._handle_return(res)\n</code></pre>"},{"location":"autoapi/client/ayon_premiere/api/ws_stub.html#client.ayon_premiere.api.ws_stub.PremiereServerStub.render","title":"<code>render(folder_url, comp_id)</code>","text":"<pre><code>Render all renderqueueitem to 'folder_url'\n</code></pre> <p>Args:     folder_url(string): local folder path for collecting Returns: None</p> Source code in <code>client/ayon_premiere/api/ws_stub.py</code> <pre><code>def render(self, folder_url, comp_id):\n    \"\"\"\n        Render all renderqueueitem to 'folder_url'\n    Args:\n        folder_url(string): local folder path for collecting\n    Returns: None\n    \"\"\"\n    res = self.websocketserver.call(self.client.call\n                                    (\"Premiere.render\",\n                                     folder_url=folder_url,\n                                     comp_id=comp_id))\n    return self._handle_return(res)\n</code></pre>"},{"location":"autoapi/client/ayon_premiere/api/ws_stub.html#client.ayon_premiere.api.ws_stub.PremiereServerStub.replace_ae_comp","title":"<code>replace_ae_comp(item_id, path, item_name, comp_names)</code>","text":"<pre><code>Imports file(s) into Bin. Used in Loader\n</code></pre> <p>Args:     item_id (str): Bin id     path (str): absolute path for AE workfile     item_name (string): label for created Bin     comp_names (list[str]): selected comp</p> Source code in <code>client/ayon_premiere/api/ws_stub.py</code> <pre><code>def replace_ae_comp(self, item_id, path, item_name, comp_names):\n    \"\"\"\n        Imports file(s) into Bin. Used in Loader\n    Args:\n        item_id (str): Bin id\n        path (str): absolute path for AE workfile\n        item_name (string): label for created Bin\n        comp_names (list[str]): selected comp\n\n    \"\"\"\n    res = self.websocketserver.call(\n        self.client.call(\n            \"Premiere.replace_ae_comp\",\n            item_id=item_id,\n            path=path,\n            item_name=item_name,\n            comp_names=comp_names\n        )\n    )\n    records = self._to_records(self._handle_return(res))\n    if records:\n        return records.pop()\n</code></pre>"},{"location":"autoapi/client/ayon_premiere/api/ws_stub.html#client.ayon_premiere.api.ws_stub.PremiereServerStub.replace_item","title":"<code>replace_item(item_id, paths, item_name, is_image_sequence)</code>","text":"<p>Replace FootageItem with new file</p> <p>Parameters:</p> Name Type Description Default <code>item_id</code> <code>int</code> required <code>paths</code> <code>string[str]</code> <p>absolute path</p> required <code>item_name</code> <code>string</code> <p>label on item in Project list</p> required <code>is_image_sequence</code> <code>bool</code> <p>if should be loaded as image seq</p> required Source code in <code>client/ayon_premiere/api/ws_stub.py</code> <pre><code>def replace_item(self, item_id, paths, item_name, is_image_sequence):\n    \"\"\" Replace FootageItem with new file\n\n        Args:\n            item_id (int):\n            paths (string[str]):absolute path\n            item_name (string): label on item in Project list\n            is_image_sequence (bool): if should be loaded as image seq\n\n    \"\"\"\n    res = self.websocketserver.call(self.client.call(\n        \"Premiere.replace_item\",\n        item_id=item_id,\n        paths=paths,\n        item_name=item_name,\n        is_image_sequence=is_image_sequence\n    ))\n\n    records = self._to_records(self._handle_return(res))\n    if records:\n        return records.pop()\n</code></pre>"},{"location":"autoapi/client/ayon_premiere/api/ws_stub.html#client.ayon_premiere.api.ws_stub.PremiereServerStub.save","title":"<code>save()</code>","text":"<pre><code>Saves active document\n</code></pre> <p>Returns: None</p> Source code in <code>client/ayon_premiere/api/ws_stub.py</code> <pre><code>def save(self):\n    \"\"\"\n        Saves active document\n    Returns: None\n    \"\"\"\n    res = self.websocketserver.call(self.client.call\n                                    (\"Premiere.save\"))\n\n    return self._handle_return(res)\n</code></pre>"},{"location":"autoapi/client/ayon_premiere/api/ws_stub.html#client.ayon_premiere.api.ws_stub.PremiereServerStub.saveAs","title":"<code>saveAs(project_path, as_copy)</code>","text":"<pre><code>Saves active project to aep (copy) or png or jpg\n</code></pre> <p>Args:     project_path(string): full local path     as_copy:  Returns: None Source code in <code>client/ayon_premiere/api/ws_stub.py</code> <pre><code>def saveAs(self, project_path, as_copy):\n    \"\"\"\n        Saves active project to aep (copy) or png or jpg\n    Args:\n        project_path(string): full local path\n        as_copy: &lt;boolean&gt;\n    Returns: None\n    \"\"\"\n    res = self.websocketserver.call(self.client.call\n                                    (\"Premiere.saveAs\",\n                                     image_path=project_path,\n                                     as_copy=as_copy))\n\n    return self._handle_return(res)\n</code></pre>"},{"location":"autoapi/client/ayon_premiere/api/ws_stub.html#client.ayon_premiere.api.ws_stub.PremiereServerStub.select_items","title":"<code>select_items(items)</code>","text":"<pre><code>Select items in Project list\n</code></pre> <p>Args:     items (list): of int item ids</p> Source code in <code>client/ayon_premiere/api/ws_stub.py</code> <pre><code>def select_items(self, items):\n    \"\"\"\n        Select items in Project list\n    Args:\n        items (list): of int item ids\n    \"\"\"\n    self.websocketserver.call(\n        self.client.call(\"Premiere.select_items\", items=items))\n</code></pre>"},{"location":"autoapi/client/ayon_premiere/api/ws_stub.html#client.ayon_premiere.api.ws_stub.PremiereServerStub.set_comp_properties","title":"<code>set_comp_properties(comp_id, start, duration, frame_rate, width, height)</code>","text":"<pre><code>Set work area to predefined values (from Ftrack).\nWork area directs what gets rendered.\nBeware of rounding, PPRO expects seconds, not frames directly.\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>comp_id</code> <code>int</code> required <code>start</code> <code>int</code> <p>workAreaStart in frames</p> required <code>duration</code> <code>int</code> <p>in frames</p> required <code>frame_rate</code> <code>float</code> <p>frames in seconds</p> required <code>width</code> <code>int</code> <p>resolution width</p> required <code>height</code> <code>int</code> <p>resolution height</p> required Source code in <code>client/ayon_premiere/api/ws_stub.py</code> <pre><code>def set_comp_properties(self, comp_id, start, duration, frame_rate,\n                        width, height):\n    \"\"\"\n        Set work area to predefined values (from Ftrack).\n        Work area directs what gets rendered.\n        Beware of rounding, PPRO expects seconds, not frames directly.\n\n    Args:\n        comp_id (int):\n        start (int): workAreaStart in frames\n        duration (int): in frames\n        frame_rate (float): frames in seconds\n        width (int): resolution width\n        height (int): resolution height\n    \"\"\"\n    res = self.websocketserver.call(self.client.call\n                                    (\"Premiere.set_comp_properties\",\n                                     item_id=comp_id,\n                                     start=start,\n                                     duration=duration,\n                                     frame_rate=frame_rate,\n                                     width=width,\n                                     height=height))\n    return self._handle_return(res)\n</code></pre>"},{"location":"autoapi/client/ayon_premiere/api/ws_stub.html#client.ayon_premiere.api.ws_stub.PremiereServerStub.set_label_color","title":"<code>set_label_color(item_id, color_idx)</code>","text":"<pre><code>Used for highlight additional information in Project panel.\nGreen color is loaded asset, blue is created asset\n</code></pre> <p>Args:     item_id (int):     color_idx (int): 0-16 Label colors from PPRO Project view</p> Source code in <code>client/ayon_premiere/api/ws_stub.py</code> <pre><code>def set_label_color(self, item_id, color_idx):\n    \"\"\"\n        Used for highlight additional information in Project panel.\n        Green color is loaded asset, blue is created asset\n    Args:\n        item_id (int):\n        color_idx (int): 0-16 Label colors from PPRO Project view\n    \"\"\"\n    res = self.websocketserver.call(self.client.call\n                                    (\"Premiere.set_label_color\",\n                                     item_id=item_id,\n                                     color_idx=color_idx))\n\n    return self._handle_return(res)\n</code></pre>"},{"location":"autoapi/client/ayon_premiere/api/ws_stub.html#client.ayon_premiere.api.ws_stub.get_stub","title":"<code>get_stub()</code>","text":"<pre><code>Convenience function to get server RPC stub to call methods directed\nfor host (Premiere).\nIt expects already created connection, started from client.\nCurrently created when panel is opened (PS: Window&gt;Extensions&gt;AYON)\n</code></pre> <p>:return:  where functions could be called from Source code in <code>client/ayon_premiere/api/ws_stub.py</code> <pre><code>def get_stub():\n    \"\"\"\n        Convenience function to get server RPC stub to call methods directed\n        for host (Premiere).\n        It expects already created connection, started from client.\n        Currently created when panel is opened (PS: Window&gt;Extensions&gt;AYON)\n    :return: &lt;PremiereServerStub&gt; where functions could be called from\n    \"\"\"\n    stub = PremiereServerStub()\n    if not stub.client:\n        raise ConnectionNotEstablishedYet(\"Connection is not created yet\")\n\n    return stub\n</code></pre>"},{"location":"autoapi/client/ayon_premiere/hooks/index.html","title":"hooks","text":""},{"location":"autoapi/client/ayon_premiere/hooks/pre_launch_args.html","title":"pre_launch_args","text":""},{"location":"autoapi/client/ayon_premiere/hooks/pre_launch_args.html#client.ayon_premiere.hooks.pre_launch_args.PremierePrelaunchHook","title":"<code>PremierePrelaunchHook</code>","text":"<p>               Bases: <code>PreLaunchHook</code></p> <p>Launch arguments preparation.</p> <p>Hook add python executable and script path to Premiere implementation before Premiere executable and add last workfile path to launch arguments.</p> <p>Existence of last workfile is checked. If workfile does not exists tries to copy templated workfile from predefined path.</p> Source code in <code>client/ayon_premiere/hooks/pre_launch_args.py</code> <pre><code>class PremierePrelaunchHook(PreLaunchHook):\n    \"\"\"Launch arguments preparation.\n\n    Hook add python executable and script path to Premiere implementation\n    before Premiere executable and add last workfile path to launch arguments.\n\n    Existence of last workfile is checked. If workfile does not exists tries\n    to copy templated workfile from predefined path.\n    \"\"\"\n    app_groups = {\"premiere\"}\n\n    order = 20\n    launch_types = {LaunchTypes.local}\n\n    def execute(self):\n        # Pop executable\n        executable_path = self.launch_context.launch_args.pop(0)\n\n        # Pop rest of launch arguments - There should not be other arguments!\n        remainders = []\n        while self.launch_context.launch_args:\n            remainders.append(self.launch_context.launch_args.pop(0))\n\n        script_path = get_launch_script_path()\n\n        new_launch_args = get_ayon_launcher_args(\n            \"run\", script_path, executable_path\n        )\n        # Add workfile path if exists\n        workfile_path = self.data[\"last_workfile_path\"]\n        if (\n            self.data.get(\"start_last_workfile\")\n            and workfile_path\n            and os.path.exists(workfile_path)\n        ):\n            new_launch_args.append(workfile_path)\n\n        workfile_startup = self.data.get(\"workfile_startup\", False)\n        self.launch_context.env[\"AYON_PREMIERE_WORKFILES_ON_LAUNCH\"] = (\n            str(workfile_startup).lower()\n        )\n\n        # Append as whole list as these arguments should not be separated\n        self.launch_context.launch_args.append(new_launch_args)\n\n        if remainders:\n            self.launch_context.launch_args.extend(remainders)\n\n        self.launch_context.kwargs = get_launch_kwargs(\n            self.launch_context.kwargs\n        )\n</code></pre>"},{"location":"autoapi/client/ayon_premiere/hooks/pre_launch_args.html#client.ayon_premiere.hooks.pre_launch_args.get_launch_kwargs","title":"<code>get_launch_kwargs(kwargs)</code>","text":"<p>Explicit setting of kwargs for Popen for Premiere.</p> <p>Expected behavior - ayon_console opens window with logs - ayon has stdout/stderr available for capturing</p> <p>Parameters:</p> Name Type Description Default <code>kwargs</code> <code>Union[dict, None]</code> <p>Current kwargs or None.</p> required Source code in <code>client/ayon_premiere/hooks/pre_launch_args.py</code> <pre><code>def get_launch_kwargs(kwargs):\n    \"\"\"Explicit setting of kwargs for Popen for Premiere.\n\n    Expected behavior\n    - ayon_console opens window with logs\n    - ayon has stdout/stderr available for capturing\n\n    Args:\n        kwargs (Union[dict, None]): Current kwargs or None.\n\n    \"\"\"\n    if kwargs is None:\n        kwargs = {}\n\n    if platform.system().lower() != \"windows\":\n        return kwargs\n\n    if is_using_ayon_console():\n        kwargs.update({\n            \"creationflags\": subprocess.CREATE_NEW_CONSOLE\n        })\n    else:\n        kwargs.update({\n            \"creationflags\": subprocess.CREATE_NO_WINDOW,\n            \"stdout\": subprocess.DEVNULL,\n            \"stderr\": subprocess.DEVNULL\n        })\n    return kwargs\n</code></pre>"},{"location":"autoapi/client/ayon_premiere/hooks/pre_launch_install_ayon_extension.html","title":"pre_launch_install_ayon_extension","text":""},{"location":"autoapi/client/ayon_premiere/hooks/pre_launch_install_ayon_extension.html#client.ayon_premiere.hooks.pre_launch_install_ayon_extension.InstallAyonExtensionToPremiere","title":"<code>InstallAyonExtensionToPremiere</code>","text":"<p>               Bases: <code>PreLaunchHook</code></p> <p>Automatically 'installs' the AYON Premiere extension.</p> <p>Checks if Premiere already has the extension in the relevant folder, will try to create that folder and unzip the extension if not.</p> Source code in <code>client/ayon_premiere/hooks/pre_launch_install_ayon_extension.py</code> <pre><code>class InstallAyonExtensionToPremiere(PreLaunchHook):\n    \"\"\"\n    Automatically 'installs' the AYON Premiere extension.\n\n    Checks if Premiere already has the extension in the relevant folder,\n    will try to create that folder and unzip the extension if not.\n    \"\"\"\n\n    app_groups = {\"premiere\"}\n\n    order = 1\n    launch_types = {LaunchTypes.local}\n\n    def execute(self):\n        try:\n            settings = self.data[\"project_settings\"][\"premiere\"]\n            if not settings[\"auto_install_extension\"]:\n                return\n            self.inner_execute()\n\n        except Exception:\n            self.log.warning(\n                \"Processing of {} crashed.\".format(self.__class__.__name__),\n                exc_info=True,\n            )\n\n    def inner_execute(self):\n        self.log.info(\"Installing AYON Premiere extension.\")\n\n        target_path = Path(\n            # roaming is applicable for windows\n            platformdirs.user_data_dir(roaming=True),\n            \"Adobe/CEP/extensions/io.ynput.PPRO.panel\"\n        )\n\n        extension_path = Path(\n            PREMIERE_ADDON_ROOT,\n            \"api\",\n            \"extension.zxp\",\n        )\n\n        # Extension already installed, compare the versions\n        if target_path.is_dir():\n            self.log.info(\n                f\"The extension already exists at: {target_path}. \"\n                f\"Comparing versions..\"\n            )\n            if not self._compare_extension_versions(\n                target_path, extension_path\n            ):\n                return\n\n        try:\n            self.log.debug(f\"Creating directory: {target_path}\")\n            target_path.mkdir(parents=True, exist_ok=True)\n\n            with ZipFile(extension_path, \"r\") as archive:\n                archive.extractall(path=target_path)\n            self.log.info(\"Successfully installed AYON extension\")\n\n        except PermissionError as error:\n            self.log.warning(f\"Permissions error has occured: {error}\")\n\n        except OSError as error:\n            self.log.warning(f\"OS error has occured: {error}\")\n\n        except Exception as error:\n            self.log.warning(f\"An unexpected error occured: {error}\")\n\n    def _compare_extension_versions(\n        self, target_path: Path, extension_path: Path\n    ) -&gt; bool:\n        try:\n            # opens the existing extension manifest to get the Version attr\n            with target_path.joinpath(\"CSXS\", \"manifest.xml\").open(\"rb\") as xml_file:\n                installed_version = (\n                    ET.parse(xml_file)\n                    .getroot()\n                    .attrib.get(\"ExtensionBundleVersion\")\n                )\n            self.log.debug(\n                f\"Current extension version found: {installed_version}\"\n            )\n\n            if not installed_version:\n                self.log.warning(\n                    \"Unable to resolve the currently installed extension \"\n                    \"version. Cancelling..\"\n                )\n                return False\n\n            # opens the .zxp manifest to get the Version attribute.\n            with ZipFile(extension_path, \"r\") as archive:\n                xml_file = archive.open(\"CSXS/manifest.xml\")\n                new_version = (\n                    ET.parse(xml_file)\n                    .getroot()\n                    .attrib.get(\"ExtensionBundleVersion\")\n                )\n                if not new_version:\n                    self.log.warning(\n                        \"Unable to resolve the new extension version. \"\n                        \"Cancelling..\"\n                    )\n                self.log.debug(f\"New extension version found: {new_version}\")\n\n                # compare the two versions, a simple == is enough since\n                # we don't care if the version increments or decrements\n                # if they match nothing happens.\n                if installed_version == new_version:\n                    self.log.info(\"Versions matched. Cancelling..\")\n                    return False\n\n                # remove the existing addon\n                self.log.info(\n                    \"Version mismatch found. Removing old extensions..\"\n                )\n                rmtree(target_path)\n                return True\n\n        except PermissionError as error:\n            self.log.warning(\n                \"Permissions error has occurred while comparing \"\n                f\"versions: {error}\"\n            )\n            return False\n\n        except OSError as error:\n            self.log.warning(\n                f\"OS error has occured while comparing versions: {error}\"\n            )\n            return False\n\n        except Exception as error:\n            self.log.warning(\n                f\"An unexpected error occured when comparing version: {error}\"\n            )\n            return False\n</code></pre>"},{"location":"autoapi/client/ayon_premiere/plugins/index.html","title":"plugins","text":""},{"location":"autoapi/client/ayon_premiere/plugins/create/index.html","title":"create","text":""},{"location":"autoapi/client/ayon_premiere/plugins/create/workfile_creator.html","title":"workfile_creator","text":""},{"location":"autoapi/client/ayon_premiere/plugins/load/index.html","title":"load","text":""},{"location":"autoapi/client/ayon_premiere/plugins/load/load_aftereffects_comp.html","title":"load_aftereffects_comp","text":""},{"location":"autoapi/client/ayon_premiere/plugins/load/load_aftereffects_comp.html#client.ayon_premiere.plugins.load.load_aftereffects_comp.AECompLoader","title":"<code>AECompLoader</code>","text":"<p>               Bases: <code>PremiereLoader</code></p> <p>Load AfterEffects composition(s) into Premiere as Bins.</p> <p>Wraps loaded items into Bins for management and stores metadata in a dedicated \"AYON Metadata\" Bin using Clip.Description field.</p> Source code in <code>client/ayon_premiere/plugins/load/load_aftereffects_comp.py</code> <pre><code>class AECompLoader(api.PremiereLoader):\n    \"\"\"Load AfterEffects composition(s) into Premiere as Bins.\n\n    Wraps loaded items into Bins for management and stores metadata in a\n    dedicated \"AYON Metadata\" Bin using Clip.Description field.\n    \"\"\"\n    label = \"Load AfterEffects Compositions\"\n    icon = \"image\"\n    product_types = {\"workfile\"}\n    representations = {\"aep\"}\n\n    def load(\n        self,\n        context: Dict[str, Any],\n        name: str = None,\n        namespace: str = None,\n        options: Dict[str, Any] = None\n    ) -&gt; None:\n        \"\"\"Main loading method for After Effects compositions.\"\"\"\n        stub = self.get_stub()\n        options = options or {}\n        repr_entity = context[\"representation\"]\n        repre_id = repr_entity[\"id\"]\n\n        # Validate path\n        path = self.filepath_from_context(context).replace(\"\\\\\", \"/\")\n        if not os.path.exists(path):\n            raise LoadError(\n                f\"Invalid path for representation {repre_id}: {path}\")\n\n        # Get selected compositions\n        selected_compositions = options.get(\n            \"compositions\") or self._get_default_compositions(context)\n        if not selected_compositions:\n            raise LoadError(\"No compositions selected for loading\")\n\n        # Process each selected composition\n        for composition in selected_compositions:\n            self._load_single_composition(\n                context=context,\n                composition=composition,\n                stub=stub,\n                path=path,\n            )\n\n    def update(\n        self,\n        container: Dict[str, Any],\n        context: Dict[str, Any]\n    ) -&gt; None:\n        \"\"\"Update container with new version or asset.\"\"\"\n        stub = self.get_stub()\n        stored_bin = container.pop(\"bin\")\n        old_metadata = stub.get_item_metadata(stored_bin)\n\n        # Get context data\n        folder_name = context[\"folder\"][\"name\"]\n        product_name = context[\"product\"][\"name\"]\n        repr_entity = context[\"representation\"]\n        repr_data = repr_entity[\"data\"]\n\n        # Handle composition to update\n        composition = self._get_composition_to_update(container, repr_data)\n        new_bin_name = self._get_updated_bin_name(\n            container, context, product_name, stub, composition\n        )\n\n        # Validate composition exists in new version\n        if composition not in repr_data.get(\"composition_names_in_workfile\",\n                                            []):\n            raise LoadError(\n                f\"Composition '{composition}' not found in workfile\")\n\n        # Perform update\n        path = self.filepath_from_context(context).replace(\"\\\\\", \"/\")\n        new_bin = stub.replace_ae_comp(\n            stored_bin.id,\n            path,\n            new_bin_name,\n            [composition]\n        )\n\n        # Update metadata\n        updated_metadata = {\n            **old_metadata,\n            \"members\": [new_bin.id],\n            \"representation\": repr_entity[\"id\"],\n            \"name\": new_bin_name,\n            \"namespace\": f\"{folder_name}_{product_name}\"\n        }\n        stub.imprint(new_bin.id, updated_metadata)\n\n    def remove(self, container: Dict[str, Any]) -&gt; None:\n        \"\"\"Remove container from Premiere project.\"\"\"\n        stub = self.get_stub()\n        stored_bin = container.pop(\"bin\")\n        stub.imprint(stored_bin.id, {})\n        stub.delete_item(stored_bin.id)\n\n    def switch(\n        self,\n        container: Dict[str, Any],\n        context: Dict[str, Any]\n    ) -&gt; None:\n        \"\"\"Allows switching folder or product\"\"\"\n        self.update(container, context)\n\n    @classmethod\n    def get_options(cls, contexts: List[Dict[str, Any]]) -&gt; List[EnumDef]:\n        \"\"\"Get composition selection options.\"\"\"\n        repr_entity = contexts[0][\"representation\"]\n        compositions = repr_entity[\"data\"].get(\"composition_names_in_workfile\",\n                                               [])\n\n        return [\n            EnumDef(\n                \"compositions\",\n                label=\"Available compositions\",\n                items={comp: comp for comp in compositions},\n                default=[compositions[0]] if compositions else [],\n                multiselection=True\n            )\n        ]\n\n    def _load_single_composition(\n        self,\n        context: Dict[str, Any],\n        composition: str,\n        stub: Any,\n        path: str,\n    ) -&gt; None:\n        \"\"\"Handle loading of a single composition.\"\"\"\n        # Generate unique bin name\n        new_bin_name = self._generate_bin_name(context, stub, composition)\n\n        # Import composition\n        import_element = stub.import_ae_comp(path, new_bin_name, [composition])\n        repre_id = context[\"representation\"][\"id\"]\n        if not import_element:\n            raise LoadError(\n                f\"Failed to load composition '{composition}' \"\n                f\"(representation {repre_id}). \"\n                \"Check host app for error details.\"\n            )\n\n        # Create container\n        product_name = context[\"product\"][\"name\"]\n        folder_name = context[\"folder\"][\"name\"]\n        namespace = f\"{folder_name}_{product_name}\"\n        api.containerise(\n            new_bin_name,\n            namespace,\n            import_element,\n            context,\n            self.__class__.__name__,\n            composition\n        )\n\n    def _generate_bin_name(\n        self,\n        context: Dict[str, Any],\n        stub: Any,\n        composition: str\n    ) -&gt; str:\n        \"\"\"Generate unique bin name for composition.\"\"\"\n        existing_bins = stub.get_items(bins=True, sequences=False,\n                                       footages=False)\n        existing_names = [bin_info.name for bin_info in existing_bins]\n        folder_name = context[\"folder\"][\"name\"]\n        product_name = context[\"product\"][\"name\"]\n        return get_unique_bin_name(\n            existing_names,\n            f\"{stub.LOADED_ICON}{folder_name}_{product_name}_{composition}\"\n        )\n\n    def _get_updated_bin_name(\n        self,\n        container: Dict[str, Any],\n        context: Dict[str, Any],\n        product_name: str,\n        stub: Any,\n        composition: str\n    ) -&gt; str:\n        \"\"\"Determine appropriate bin name for updated container.\n\n        Returns existing name if namespace matches, generates new unique name if not.\n        \"\"\"\n        folder_name = context[\"folder\"][\"name\"]\n        new_namespace = f\"{folder_name}_{product_name}\"\n\n        if container[\"namespace\"] != new_namespace:\n            # Asset switch - need new unique name\n            return self._generate_bin_name(context, stub, composition)\n\n        # Version update - keep existing name\n        return container[\"name\"]\n\n    def _get_default_compositions(self, context: Dict[str, Any]) -&gt; List[str]:\n        \"\"\"Get default compositions from representation data.\"\"\"\n        return context[\"representation\"][\"data\"].get(\n            \"composition_names_in_workfile\", [])\n\n    def _get_composition_to_update(\n        self,\n        container: Dict[str, Any],\n        repr_data: Dict[str, Any]\n    ) -&gt; str:\n        \"\"\"Get composition name for update operation.\"\"\"\n        if composition := container.get(\"imported_composition\"):\n            return composition\n\n        # Backward compatibility for older containers\n        if comp_names := repr_data.get(\"composition_names_in_workfile\"):\n            return comp_names[0]\n\n        raise LoadError(\"No composition found for update\")\n</code></pre>"},{"location":"autoapi/client/ayon_premiere/plugins/load/load_aftereffects_comp.html#client.ayon_premiere.plugins.load.load_aftereffects_comp.AECompLoader.get_options","title":"<code>get_options(contexts)</code>  <code>classmethod</code>","text":"<p>Get composition selection options.</p> Source code in <code>client/ayon_premiere/plugins/load/load_aftereffects_comp.py</code> <pre><code>@classmethod\ndef get_options(cls, contexts: List[Dict[str, Any]]) -&gt; List[EnumDef]:\n    \"\"\"Get composition selection options.\"\"\"\n    repr_entity = contexts[0][\"representation\"]\n    compositions = repr_entity[\"data\"].get(\"composition_names_in_workfile\",\n                                           [])\n\n    return [\n        EnumDef(\n            \"compositions\",\n            label=\"Available compositions\",\n            items={comp: comp for comp in compositions},\n            default=[compositions[0]] if compositions else [],\n            multiselection=True\n        )\n    ]\n</code></pre>"},{"location":"autoapi/client/ayon_premiere/plugins/load/load_aftereffects_comp.html#client.ayon_premiere.plugins.load.load_aftereffects_comp.AECompLoader.load","title":"<code>load(context, name=None, namespace=None, options=None)</code>","text":"<p>Main loading method for After Effects compositions.</p> Source code in <code>client/ayon_premiere/plugins/load/load_aftereffects_comp.py</code> <pre><code>def load(\n    self,\n    context: Dict[str, Any],\n    name: str = None,\n    namespace: str = None,\n    options: Dict[str, Any] = None\n) -&gt; None:\n    \"\"\"Main loading method for After Effects compositions.\"\"\"\n    stub = self.get_stub()\n    options = options or {}\n    repr_entity = context[\"representation\"]\n    repre_id = repr_entity[\"id\"]\n\n    # Validate path\n    path = self.filepath_from_context(context).replace(\"\\\\\", \"/\")\n    if not os.path.exists(path):\n        raise LoadError(\n            f\"Invalid path for representation {repre_id}: {path}\")\n\n    # Get selected compositions\n    selected_compositions = options.get(\n        \"compositions\") or self._get_default_compositions(context)\n    if not selected_compositions:\n        raise LoadError(\"No compositions selected for loading\")\n\n    # Process each selected composition\n    for composition in selected_compositions:\n        self._load_single_composition(\n            context=context,\n            composition=composition,\n            stub=stub,\n            path=path,\n        )\n</code></pre>"},{"location":"autoapi/client/ayon_premiere/plugins/load/load_aftereffects_comp.html#client.ayon_premiere.plugins.load.load_aftereffects_comp.AECompLoader.remove","title":"<code>remove(container)</code>","text":"<p>Remove container from Premiere project.</p> Source code in <code>client/ayon_premiere/plugins/load/load_aftereffects_comp.py</code> <pre><code>def remove(self, container: Dict[str, Any]) -&gt; None:\n    \"\"\"Remove container from Premiere project.\"\"\"\n    stub = self.get_stub()\n    stored_bin = container.pop(\"bin\")\n    stub.imprint(stored_bin.id, {})\n    stub.delete_item(stored_bin.id)\n</code></pre>"},{"location":"autoapi/client/ayon_premiere/plugins/load/load_aftereffects_comp.html#client.ayon_premiere.plugins.load.load_aftereffects_comp.AECompLoader.switch","title":"<code>switch(container, context)</code>","text":"<p>Allows switching folder or product</p> Source code in <code>client/ayon_premiere/plugins/load/load_aftereffects_comp.py</code> <pre><code>def switch(\n    self,\n    container: Dict[str, Any],\n    context: Dict[str, Any]\n) -&gt; None:\n    \"\"\"Allows switching folder or product\"\"\"\n    self.update(container, context)\n</code></pre>"},{"location":"autoapi/client/ayon_premiere/plugins/load/load_aftereffects_comp.html#client.ayon_premiere.plugins.load.load_aftereffects_comp.AECompLoader.update","title":"<code>update(container, context)</code>","text":"<p>Update container with new version or asset.</p> Source code in <code>client/ayon_premiere/plugins/load/load_aftereffects_comp.py</code> <pre><code>def update(\n    self,\n    container: Dict[str, Any],\n    context: Dict[str, Any]\n) -&gt; None:\n    \"\"\"Update container with new version or asset.\"\"\"\n    stub = self.get_stub()\n    stored_bin = container.pop(\"bin\")\n    old_metadata = stub.get_item_metadata(stored_bin)\n\n    # Get context data\n    folder_name = context[\"folder\"][\"name\"]\n    product_name = context[\"product\"][\"name\"]\n    repr_entity = context[\"representation\"]\n    repr_data = repr_entity[\"data\"]\n\n    # Handle composition to update\n    composition = self._get_composition_to_update(container, repr_data)\n    new_bin_name = self._get_updated_bin_name(\n        container, context, product_name, stub, composition\n    )\n\n    # Validate composition exists in new version\n    if composition not in repr_data.get(\"composition_names_in_workfile\",\n                                        []):\n        raise LoadError(\n            f\"Composition '{composition}' not found in workfile\")\n\n    # Perform update\n    path = self.filepath_from_context(context).replace(\"\\\\\", \"/\")\n    new_bin = stub.replace_ae_comp(\n        stored_bin.id,\n        path,\n        new_bin_name,\n        [composition]\n    )\n\n    # Update metadata\n    updated_metadata = {\n        **old_metadata,\n        \"members\": [new_bin.id],\n        \"representation\": repr_entity[\"id\"],\n        \"name\": new_bin_name,\n        \"namespace\": f\"{folder_name}_{product_name}\"\n    }\n    stub.imprint(new_bin.id, updated_metadata)\n</code></pre>"},{"location":"autoapi/client/ayon_premiere/plugins/load/load_file.html","title":"load_file","text":""},{"location":"autoapi/client/ayon_premiere/plugins/load/load_file.html#client.ayon_premiere.plugins.load.load_file.FileLoader","title":"<code>FileLoader</code>","text":"<p>               Bases: <code>PremiereLoader</code></p> <p>Load footage (images/movies) or audio files</p> <p>Wraps loaded item into Bin (to be able to delete it if necessary) Stores the imported asset in a container named after the asset.</p> <p>Metadata stored in dummy <code>AYON Metadata</code> Bin in Clip.Description field.</p> Source code in <code>client/ayon_premiere/plugins/load/load_file.py</code> <pre><code>class FileLoader(api.PremiereLoader):\n    \"\"\"Load footage (images/movies) or audio files\n\n    Wraps loaded item into Bin (to be able to delete it if necessary)\n    Stores the imported asset in a container named after the asset.\n\n    Metadata stored in dummy `AYON Metadata` Bin in Clip.Description field.\n    \"\"\"\n    label = \"Load file\"\n    icon = \"image\"\n\n    product_types: set[str] = {\"*\"}\n    representations: set[str] = {\"*\"}\n    extensions: set[str] = set(\n        ext.lstrip(\".\") for ext in IMAGE_EXTENSIONS.union(VIDEO_EXTENSIONS)\n    )\n\n    def load(self, context: dict, name=None, namespace=None, data=None):\n        stub = self.get_stub()\n        repr_id = context[\"representation\"][\"id\"]\n\n        new_bin_name = self._get_bin_name(context, name, stub)\n\n        path = self.filepath_from_context(context)\n        if not path or not os.path.exists(path):\n            raise LoadError(\n                f\"Representation id `{repr_id}` has invalid path `{path}`\")\n\n        paths = [path]\n\n        image_sequence = False\n        if len(context[\"representation\"][\"files\"]) &gt; 1:\n            image_sequence = True\n            dir_path = os.path.dirname(path)\n            paths = [os.path.join(dir_path, repre_file[\"name\"])\n                     for repre_file in context[\"representation\"][\"files\"]]\n\n        paths = [path.replace(\"\\\\\", \"/\") for path in paths]\n\n        import_element = stub.import_files(paths, new_bin_name, image_sequence)\n\n        if not import_element:\n            msg = (f\"Representation id `{repr_id}` failed to load.\"\n                    \"Check host app for alert error.\")\n            raise LoadError(msg)\n\n        self[:] = [import_element]\n        folder_name = context[\"folder\"][\"name\"]\n        # imported product with folder, eg. \"chair_renderMain\"\n        namespace = f\"{folder_name}_{name}\"\n        return api.containerise(\n            new_bin_name,  # \"{stub.LOADED_ICON}chair_renderMain_001\"\n            namespace,     # chair_renderMain\n            import_element,\n            context,\n            self.__class__.__name__\n        )\n\n    def update(self, container: dict, context: dict):\n        \"\"\"Switch asset or change version\"\"\"\n        stub = self.get_stub()\n        stored_bin = container.pop(\"bin\")\n        old_metadata = stub.get_item_metadata(stored_bin)\n\n        folder_name = context[\"folder\"][\"name\"]\n        product_name = context[\"product\"][\"name\"]\n        repre_entity = context[\"representation\"]\n\n        new_container_name = f\"{folder_name}_{product_name}\"\n        # switching assets\n        if container[\"namespace\"] != new_container_name:\n            new_bin_name = self._get_bin_name(context, product_name, stub)\n        else:  # switching version - keep same name\n            new_bin_name = container[\"name\"]\n        paths = [get_representation_path(repre_entity)]\n\n        is_image_sequence = False\n        if len(repre_entity[\"files\"]) &gt; 1:\n            is_image_sequence = True\n            dir_path = os.path.dirname(paths[0])\n            paths = [\n                os.path.join(dir_path, repre_file[\"name\"])\n                for repre_file in context[\"representation\"][\"files\"]\n            ]\n\n        paths = [path.replace(\"\\\\\", \"/\") for path in paths]\n        new_bin = stub.replace_item(\n            stored_bin.id, paths, new_bin_name, is_image_sequence)\n\n        # new bin might be created\n        old_metadata[\"members\"] = [new_bin.id]\n        old_metadata[\"representation\"] = repre_entity[\"id\"]\n        old_metadata[\"name\"] = new_bin_name\n        old_metadata[\"namespace\"] = new_container_name\n        stub.imprint(\n            new_bin.id,\n            old_metadata\n        )\n\n    def remove(self, container: dict):\n        \"\"\"Removes element from scene: deletes layer + removes from Headline\n        Args:\n            container (dict): container to be removed - used to get layer_id\n        \"\"\"\n        stub = self.get_stub()\n        stored_bin = container.pop(\"bin\")\n        stub.imprint(stored_bin.id, {})\n        stub.delete_item(stored_bin.id)\n\n    def switch(self, container, context):\n        self.update(container, context)\n\n    def _get_bin_name(self, context: dict, product_name: str, stub) -&gt; str:\n        existing_bins = stub.get_items(\n            bins=True, sequences=False, footages=False)\n        existing_bin_names = [bin_info.name for bin_info in existing_bins]\n        folder_name = context[\"folder\"][\"name\"]\n        new_bin_name = get_unique_bin_name(\n            existing_bin_names,\n            f\"{stub.LOADED_ICON}{folder_name}_{product_name}\"\n        )\n        return new_bin_name\n</code></pre>"},{"location":"autoapi/client/ayon_premiere/plugins/load/load_file.html#client.ayon_premiere.plugins.load.load_file.FileLoader.remove","title":"<code>remove(container)</code>","text":"<p>Removes element from scene: deletes layer + removes from Headline Args:     container (dict): container to be removed - used to get layer_id</p> Source code in <code>client/ayon_premiere/plugins/load/load_file.py</code> <pre><code>def remove(self, container: dict):\n    \"\"\"Removes element from scene: deletes layer + removes from Headline\n    Args:\n        container (dict): container to be removed - used to get layer_id\n    \"\"\"\n    stub = self.get_stub()\n    stored_bin = container.pop(\"bin\")\n    stub.imprint(stored_bin.id, {})\n    stub.delete_item(stored_bin.id)\n</code></pre>"},{"location":"autoapi/client/ayon_premiere/plugins/load/load_file.html#client.ayon_premiere.plugins.load.load_file.FileLoader.update","title":"<code>update(container, context)</code>","text":"<p>Switch asset or change version</p> Source code in <code>client/ayon_premiere/plugins/load/load_file.py</code> <pre><code>def update(self, container: dict, context: dict):\n    \"\"\"Switch asset or change version\"\"\"\n    stub = self.get_stub()\n    stored_bin = container.pop(\"bin\")\n    old_metadata = stub.get_item_metadata(stored_bin)\n\n    folder_name = context[\"folder\"][\"name\"]\n    product_name = context[\"product\"][\"name\"]\n    repre_entity = context[\"representation\"]\n\n    new_container_name = f\"{folder_name}_{product_name}\"\n    # switching assets\n    if container[\"namespace\"] != new_container_name:\n        new_bin_name = self._get_bin_name(context, product_name, stub)\n    else:  # switching version - keep same name\n        new_bin_name = container[\"name\"]\n    paths = [get_representation_path(repre_entity)]\n\n    is_image_sequence = False\n    if len(repre_entity[\"files\"]) &gt; 1:\n        is_image_sequence = True\n        dir_path = os.path.dirname(paths[0])\n        paths = [\n            os.path.join(dir_path, repre_file[\"name\"])\n            for repre_file in context[\"representation\"][\"files\"]\n        ]\n\n    paths = [path.replace(\"\\\\\", \"/\") for path in paths]\n    new_bin = stub.replace_item(\n        stored_bin.id, paths, new_bin_name, is_image_sequence)\n\n    # new bin might be created\n    old_metadata[\"members\"] = [new_bin.id]\n    old_metadata[\"representation\"] = repre_entity[\"id\"]\n    old_metadata[\"name\"] = new_bin_name\n    old_metadata[\"namespace\"] = new_container_name\n    stub.imprint(\n        new_bin.id,\n        old_metadata\n    )\n</code></pre>"},{"location":"autoapi/client/ayon_premiere/plugins/publish/index.html","title":"publish","text":""},{"location":"autoapi/client/ayon_premiere/plugins/publish/collect_current_file.html","title":"collect_current_file","text":"Requires <p>None</p> Provides <p>context.data[\"currentFile\"] -&gt;  absolute path for workfile</p>"},{"location":"autoapi/client/ayon_premiere/plugins/publish/collect_current_file.html#client.ayon_premiere.plugins.publish.collect_current_file.CollectCurrentFile","title":"<code>CollectCurrentFile</code>","text":"<p>               Bases: <code>ContextPlugin</code></p> <p>Inject the current working file path into context</p> Source code in <code>client/ayon_premiere/plugins/publish/collect_current_file.py</code> <pre><code>class CollectCurrentFile(pyblish.api.ContextPlugin):\n    \"\"\"Inject the current working file path into context\"\"\"\n\n    order = pyblish.api.CollectorOrder - 0.49\n    label = \"Current File\"\n    hosts = [\"premiere\"]\n\n    def process(self, context):\n        context.data[\"currentFile\"] = os.path.normpath(\n            get_stub().get_active_document_full_name()\n        ).replace(\"\\\\\", \"/\")\n</code></pre>"},{"location":"autoapi/client/ayon_premiere/plugins/publish/collect_workfile.html","title":"collect_workfile","text":"Requires <p>None</p> Provides <p>instance.data[\"representations\"] -&gt;  workfile representation</p>"},{"location":"autoapi/client/ayon_premiere/plugins/publish/collect_workfile.html#client.ayon_premiere.plugins.publish.collect_workfile.CollectWorkfile","title":"<code>CollectWorkfile</code>","text":"<p>               Bases: <code>ContextPlugin</code></p> <p>Adds 'workfile' representation if instance is published.</p> Source code in <code>client/ayon_premiere/plugins/publish/collect_workfile.py</code> <pre><code>class CollectWorkfile(pyblish.api.ContextPlugin):\n    \"\"\" Adds 'workfile' representation if instance is published. \"\"\"\n\n    label = \"Collect Premiere Workfile Instance\"\n    order = pyblish.api.CollectorOrder + 0.1\n\n    def process(self, context):\n        workfile_instance = None\n        for instance in context:\n            if instance.data[\"productType\"] == \"workfile\":\n                self.log.debug(\"Workfile instance found\")\n                workfile_instance = instance\n                break\n\n        if workfile_instance is None:\n            self.log.debug(\"Workfile instance not found. Skipping\")\n            return\n\n        current_file = context.data[\"currentFile\"]\n        staging_dir = os.path.dirname(current_file)\n        scene_file = os.path.basename(current_file)\n\n        # creating representation\n        workfile_instance.data[\"representations\"].append({\n            \"name\": \"prproj\",\n            \"ext\": \"prproj\",\n            \"files\": scene_file,\n            \"stagingDir\": staging_dir,\n        })\n</code></pre>"},{"location":"autoapi/client/ayon_premiere/plugins/publish/increment_workfile.html","title":"increment_workfile","text":""},{"location":"autoapi/client/ayon_premiere/plugins/publish/increment_workfile.html#client.ayon_premiere.plugins.publish.increment_workfile.IncrementWorkfile","title":"<code>IncrementWorkfile</code>","text":"<p>               Bases: <code>ContextPlugin</code>, <code>OptionalPyblishPluginMixin</code></p> <p>Increment the current workfile.</p> <p>Saves the current scene with an increased version number.</p> Source code in <code>client/ayon_premiere/plugins/publish/increment_workfile.py</code> <pre><code>class IncrementWorkfile(\n    pyblish.api.ContextPlugin,\n    OptionalPyblishPluginMixin\n):\n    \"\"\"Increment the current workfile.\n\n    Saves the current scene with an increased version number.\n    \"\"\"\n\n    label = \"Increment Workfile\"\n    order = pyblish.api.IntegratorOrder + 9.0\n    hosts = [\"premiere\"]\n    optional = True\n\n    def process(self, context: pyblish.api.Context):\n        if not self.is_active(context.data):\n            return\n\n        errored_plugins = get_errored_plugins_from_context(context)\n        if errored_plugins:\n            raise RuntimeError(\n                \"Skipping incrementing current file because publishing failed.\"\n            )\n\n        host: IWorkfileHost = registered_host()\n        current_filepath: str = context.data[\"currentFile\"]\n        try:\n            from ayon_core.pipeline.workfile import save_next_version\n            from ayon_core.host.interfaces import SaveWorkfileOptionalData\n\n            current_filename = os.path.basename(current_filepath)\n            save_next_version(\n                description=(\n                    f\"Incremented by publishing from {current_filename}\"\n                ),\n                # Optimize the save by reducing needed queries for context\n                prepared_data=SaveWorkfileOptionalData(\n                    project_entity=context.data[\"projectEntity\"],\n                    project_settings=context.data[\"project_settings\"],\n                    anatomy=context.data[\"anatomy\"],\n                )\n            )\n            new_filepath = host.get_current_workfile()\n        except ImportError:\n            # Backwards compatibility before ayon-core 1.5.0\n            self.log.debug(\n                \"Using legacy `version_up`. Update AYON core addon to \"\n                \"use newer `save_next_version` function.\"\n            )\n            new_filepath = version_up(current_filepath)\n            host.save_workfile(new_filepath)\n\n        self.log.debug(f\"Incremented workfile to: {new_filepath}\")\n</code></pre>"},{"location":"autoapi/server/index.html","title":"server","text":""},{"location":"autoapi/server/settings.html","title":"settings","text":""}]}